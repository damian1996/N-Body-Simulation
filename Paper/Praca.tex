\documentclass[14pt,twoside,a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bera}
\usepackage{blindtext}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{caption}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{calc}
\usepackage{color}
\usepackage{fontenc}
\usepackage[document]{ragged2e}
\usepackage{bm}
\usepackage{pstricks}
\usepackage{tikz}
\usepackage{auto-pst-pdf}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{hyperref}
\usepackage[
backend=biber,
bibstyle=numeric,
citestyle=numeric,
]{biblatex}
\addbibresource{biblio.bib}
\hypersetup{
  colorlinks, linkcolor=red, citecolor=red
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\definecolor{mygreen}{rgb}{0,0.6,0}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\newtheorem{theorem}{Prawo}
\newenvironment{myproof}[2] {\paragraph{Dowód:}}{\hfill$\square$}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]

%\geometry{left=2.5cm,right=2.5cm,top=10.0cm,bottom=2.5cm}
\begin{document}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	
	\center
	
	\textsc{\Large Uniwersytet  Jagielloński\\
			 Wydział Matematyki i Informatyki\\
    		 Zespół Katedr i Zakładów Informatyki Matematycznej}\\[1.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\HRule\\[0.4cm]
		
	{\huge\bfseries Wielowątkowa symulacja N ciał z implementacją w architekturze CUDA}\\[0.4cm] % Title 
	
	\HRule\\[1.5cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Autor}\\
			Damian Stachura% \textsc{Stachura}  Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Opiekun}\\
			dr Maciej Ślusarek %\textsc{Ślusarek}  Supervisor's name
		\end{flushright}
	\end{minipage}
	
	\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
\end{titlepage}

\newpage
\tableofcontents

\newpage

\section{\LARGE Przedstawienie problemu symulacji N ciał}
\bigskip
Symulacja N ciał jest zagadnieniem z mechaniki klasycznej, które polega na wyznaczeniu toru ruchów wszystkich ciał danego układu o danych masach, prędkościach i położeniach początkowych w oparciu o prawa ruchu i założenie, że ciała oddziałują ze sobą zgodnie z prawem grawitacji Newtona. \\ 
Podstawowe zagadnienia do symulacji N ciał zostały przedstawione przez Isaaca Newtona w 1687 roku, który wprowadził prawa(później zostaną przedstawione dokładniej), które obowiązują przy próbach analitycznego rozwiązania problemu. \cite{Newton}.

\subsection{\Large Szczególne przypadki}
Problem analitycznego wyznaczenia dokładnego ruchu dowolnej liczby ciał jest trudny, więc można znaleźć wiele prac skupiająych się jedynie na ustalonej, małej liczbe ciał.

\subsubsection{\large Problem dwóch ciał}
Problem dla dwóch ciał podlegających prawom klasycznej dynamiki Newtona i przyciągających się zgodnie z newtonowskim prawem powszechnego ciążenia został analitycznie rozstrzygnięty przez J. Bernoulliego przy założeniu, że masa obiektu koncentruje się w jego środku. \cite[str.~1-49]{fund}

Obydwa ciała poruszają się po krzywych stożkowych, których rodzaj zależy od całkowitej energii układu. Przykładowo, gdy energia jest mała, to ciała nie mogą się od siebie uwolnić, więc krążą wokół siebie po elipsach. (Figure \ref{fig:kulki})

\subsubsection{\large Problem trzech ciał}
Problem trzech ciał wciąż nie został rozwiązany analitycznie w ogólności. Jednakże istnieją rozwiązania dla uproszczonych wersji tego problemu, jak na przykład gdy masy obiektów są równe \cite{threebody1} lub w przypadku gdy w układzie mamy trzy równoległe względem siebie linie, a każde z ciał porusza się po jednej z prostych \cite{threebody2}, a także gdy masa jednego z ciał obecnych w systemi jest zaniedbywalnie mała(jest to tak zwany ograniczony problem trzech ciał - przedstawiony przez J. L. Lagrange'a w XVIII wieku). \cite{szebehely}


\subsection{\Large Zastosowania}
Symulacje N ciał są szeroko wykorzystywanymi narzędziami w fizyce oraz astronomii. Problemem, w którym symulacje są użyteczne jest na przykład dynamika systemu z kilkoma ciałami jak układ Słońce-Ziemia-Księżyc \cite{SEMmisc} lub dynamika systemów gwiezdnych. \cite{chaosMisc}\\
W kosmologii symulacje są wykorzystywane do studiowania procesów tworzenia nieliniowych struktur jak galaktyczne halo z wpływem ciemnej materii \cite{haloDensity}. 
Z kolei, bezpośrednie symulacje N ciał są wykorzystywane na przykład do studiowania dynamicznej ewolucji klastrów gwiazd lub do symulacji dynamiki planetozymali. \cite{dirNBody}. Zastosowania symulacji można zaobserwować również w innych dziedzinach, chociażby w algorytmach rysowania grafu skierowanego siłą. \cite{visGraph} Powyższe przykłady pokazują jak różnorodny jest zakres zastosowań symulacji.
\newpage

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{kulki.pdf_tex}
    \caption{Symulacja dwóch ciał poruszających się po elipsach}
    \label{fig:kulki}
\end{figure}


\subsection{\Large Implementacja i wykorzystane technologie}
W pierwszej części mojej pracy przedstawię równoległą implementację naiwnego algorytmu symulacji N ciał. W każdym kroku algorytm bezpośrednio wyznacza siły oddziałujące wzajemnie pomiędzy każdymi dwoma ciałami w systemie, przez co oblicza całkowitą siłę oddziałującą na każde ciało w jednym kroku symulacji. W drugiej części zaimplementuję wielowątkowo algorytm Barnes Hut'a, który korzysta z drzew ósemkowych.

Repozytorium jest dostępne pod tym \href{https://github.com/damian1996/N-Body-Simulation}{linkiem}.
Całość została zaimplementowana w C++. Innymi technologiami wykorzystanymi w pracy są OpenGL, CUDA czy Thrust, których zastosowanie zostanie wspomniane później. \\
Pełna instrukcja instalacji niezbędnego oprogramowania do uruchomienia symulacji jest zawarta w repozytorium (dla linuxa Ubuntu).

\section{\LARGE Teoretyczne podstawy symulacji N ciał}

W celu przedstawienia ogólnego sformułowania problemu potrzebujemy przytoczyć trzy prawa dynamiki sformułowane przez Isaaca Newtona: \cite[str.~3-4]{fund}

\begin{theorem}
Każde ciało pozostaje w stanie spoczynku lub ruchu jednostajnego w linii prostej, chyba że jest zmuszone zmienić ten stan przez zewnętrzne oddziaływanie z innymi ciałami, czyli każde ciało jest w układzie inercjalnym.
\end{theorem}

\begin{theorem}
Szybkość zmiany pędu jest proporcjonalna do siły wywieranej i znajduje się w tym samym kierunku co siła.
\end{theorem}
Co oznacza, że w inercjalnym układzie odniesienia zachodzi równość $F=ma$, gdzie $F$ jest wektorem sum sił działających na obiekt, $m$ to masa obiektu, $a$ to jego przyśpieszenie.

\begin{theorem}
Każdej akcji towarzyszy reakcja równa co do wartości i kierunku, lecz przeciwnie zwrócona.
\end{theorem} 
Co oznacza, że jeśli ciało A działa na ciało B siłą F (akcja), to ciało B działa na ciało A siłą (reakcja) o takiej samej wartości i kierunku, lecz o przeciwnym zwrocie.\\~\\


Niezbędne jest również przytoczenie prawa powszechnego ciążenia Newtona \cite[str.~4-5]{fund}
\begin{theorem}
Każdy obiekt przyciąga każdy inny obiekt z siłą, która jest wprost proporcjonalna do iloczynu ich mas i odwrotnie proporcjonalna do kwadratu odległości między ich środkami.
\end{theorem}
Czyli między dowolną parą ciał posiadających masy pojawia się siła przyciągająca, która działa na linii łączącej ich środki, a jej wartość rośnie z iloczynem ich mas i maleje z kwadratem odległości.\\~\\

Aplikując to prawo do symulacji N ciał, uzyskujemy że na każde $i$-te ciało działa siła $F_i$ zdefiniowana następująco:\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$gdzie $m_i$ masa ciała na które oddziałują inne ciała, $m_j$ masa ciała oddziałującego na $i$-te ciało, $r_i - r_j$ to różnica wektorów pozycji dwóch ciał, $|r_i - r_j|$ to dystans między ciałami, a $G$ to stała grawitacji i wynosi
\begin{center}
$$G = 6,67408(31)\cdot 10^{-11} \frac{m^{3}}{kg s^2}.$$
\end{center}
Z wykorzystaniem powyższych praw możemy podać następującą definicję
\paragraph{Symulacja N ciał} 
\newcommand{\mi}{\boldsymbol{} \mathrel{\mkern -16mu} \boldsymbol{-}}
$\mi$
Dla N ciał mających ustalone masy oraz początkowe położenie i prędkość, ruch każdego obiektu jest symulowany z wykorzystaniem prawa powszechnego ciążenia oraz poprzez wyznaczenie przyspieszenia obiektu korzystając z drugiego prawa dynamiki Newtona.\\
\bigskip
Potrzebujemy zdefiniować jeszcze jedno pojęcie, jakim jest \textbf{ruch jednostajnie przyśpieszony prostoliniowy}.
Konkretniej będziemy potrzebować wyprowadzonych wzorów na zmianę prędkości i pokonaną drogę przez obiekt w danym odcinku czasu.
$$v_k = v_p + a\cdot t,$$ gdzie $v_k$ jest prędkością po wykonaniu kroku symulacji, $v_p$ jest prędkością początkową, $a$ oznacza wektora przyśpieszenia, a $t$ to czas kroku symulacji.\\
Drugim wzorem jest:
$$s = v_p\cdot t + \frac{a\cdot t^2}{2},$$ gdzie $s$ oznacza drogą przebytą w jednym kroku, a pozostałe oznaczenia są identyczne jak powyżej.\\
\newpage
Tak zdefiniowana symulacja N ciał spotyka się z następującymi problemami:
\begin{itemize}
\item Kiedy ciała są bardzo bliskie siebie, wtedy zadziała na nie ogromna siła, która w rzeczywistości będzie działała na ciało przez krótki czas. To znaczy krok symulacji może trwać znacznie dłużej niż czas, przez który obiekty będą blisko siebie. Przez to na ciało zadziała o wiele za duża siła niż powinna.
\item Ciało w pojedynczym kroku symulacji porusza się ruchem jednostajnie przyśpieszonym prostoliniowym, więc ruch w całej symulacji jest jedynie aproksymacją poprzez sklejeniem tych odcinków czasu.
\end{itemize}

\section{\LARGE Naiwny algorytm symulacji N ciał}
\bigskip

\subsection{\Large Jednowątkowa wersja naiwnego algorytmu}

Każde ciało na początku symulacji ma pseudolosową pozycję, prędkość oraz masę. W mojej symulacji odległości są wyrażone w metrach, masy ciał są podane w kilogramach, a jednostką prędkości jest metr na sekundę. \\


Prosty pseudokod dla algorytmu symulującego problem N ciał może wyglądać następująco:\\
\bigskip
\lstset{
	backgroundcolor=\color{white},
	basicstyle=\footnotesize\fontfamily{fvm}\selectfont,
	numbers=left, 
	numbersep=8pt,	
	keywordstyle=\color{blue},
	commentstyle = \color{mygreen},
	literate=%
	%	zażółć gęślą jaźń
	{ź}{{\'z}}1
	{ż}{{\.z}}1
	{ń}{{\'n}}1
	{ó}{{\'o}}1
	{ł}{{\l{}}}1
	{ć}{{\'c}}1
	{ą}{{\k{a}}}1
	{ę}{{\k{e}}}1
	{ś}{{\'s}}1
}
\begin{lstlisting}[frame=single, framerule=2pt, caption=Pseudokod naiwnego algorytmu]
ustaw masę oraz początkową pozycję i prędkość dla każdego ciała
while(true):
  for i in {1...N}:
    for j in {1...N}:
      if (i!=j):
        Force[i] += SiłaPomiedzyCiałami(i, j) 
  for i in {1...N}:
    UaktualnijPozycjeCiała(i)
\end{lstlisting}

\bigskip

W liniach 3-6 tego algorytmu liczymy bezpośrednio siłę z jaką dwa ciała oddziałują na siebie dla każdej możliwej pary ciał. Jest to najbardziej kosztowna operacja w tym algorytmie, której złożoność to $\mathcal{O}(N^{2})$. W linii 7 uaktualniamy pozycję każdego ciała uwzględniając całkowitą siłę, która na nie działa. Siła ta wynika z powyżęj przytoczonego wzoru. 
\bigskip
\newtheorem{twr}{Twierdzenie}
\begin{twr}
Jednowątkowy naiwny algorytm dla symulacji N ciał złożoność obliczeniową $\mathcal{O}(N^{2})$.
\end{twr}

\begin{myproof}

\tab Dla każdego z $N$ obiektów musimy policzyć siłę oddziałującą nań z każdym innym obiektem, więc musimy $N\cdot (N-1)$ razy policzyć wartość wzoru wynikającego z prawa $4$. Z tego wynika, że złożoność tej podoperacji $\mathcal{O}(N^{2})$. 
Następnie dla każdego obiektu musimy wyznaczyć jego przyśpieszenie oraz nową pozycję i prędkość, co jesteśmy w stanie zrobić w czasie $\mathcal{O}(N)$.
Poprzez zsumowanie złożoności obu podoperacji, widzimy że złożoność obliczeniowa jednego kroku symulacji naiwnego algorytmu wynosi $\mathcal{O}(N^{2})$.
\end{myproof}

\bigskip

\subsection{\Large Zrównoleglenie naiwnego algorytmu}

Jednakże ten algorytm jest zbyt wolny dla dużej liczby ciał. W tym podrozdziale zoptymalizujemy go poprzez zrównoleglenie obliczeń. Wyliczenie siły oddziałującej na pewne ciało oraz wyznaczenie mu nowej pozycji są niezależne względem tych obliczeń dla pozostałych ciał. A to oznacza, że pojedynczy krok algorytmu możemy policzyć równolegle dla każdego obiektu.

\subsubsection{\large Architektura CUDA}
W tym celu wykorzystamy architekturę CUDA. 
Jest to uniwersalna architektura kart graficznych(które dzisiejszych czasach poza zastosowaniem w renderowaniu grafiki, są również często używane do masywnych obliczeń nawet na tysiącach wątków jednocześnie), umożliwiająca wykorzystanie ich mocy obliczeniowej w wielu problemach, które mogą się wykonywać zarówno sekwencyjne i wielowątkowo. Wykorzystałem CUDĘ w wersji v9.1.85 z compute compability 3.0 i wyżej. \\~\\
Wątki na CUDA są pogrupowane w bloki. W compute compability 3.0 każdy blok może mieć do 1024 wątków. Z kolei bloki są ułożone w gridzie, który może być nawet trójwymiarowy. W wymiarze X może być aż $2^{31}-1$ wątków, w dwóch pozostałych $65535$. \cite[str.~238-242]{Cuda} Dodatkowo wątki są grupowane w mniejsze grupy niż bloki, zwane warpami, które liczą po 32 wątki. Wątki w jednym warpie są uruchamiane jednocześnie i zarządzane przez warp scheduler \cite[str.~70]{Cuda} \\
\bigskip
Warto, także wspomnieć o podziale pamięci w programach pisanych w tej architekturze. \\Możemy wyróżnić trzy rodzaje pamięci :
\begin{itemize}
  \item lokalna - osobna dla każdego wątku, czyli wątki mogą mieć zmienne lokalne na swój użytek,
  \item współdzielona - pamięć dzielona przez wszystkie wątki w bloku(ale jest jej tylko 48kb \cite[str.~238-242]{Cuda}),
  \item globalna - najwolniejsza ze wszystkich rodzajów pamięci, ale wspólna dla wszystkich bloków.
\end{itemize}

\subsubsection{\large Thrust}
Thrust jest szablonową biblioteką dla CUDA bazująca na bibliotece STL z C++. Thrust umożliwia implementację aplikacji wielowątkowych za pośrednictwem interfejsu wysokiego poziomu, który jest w pełni zgodny z CUDA C. Korzystałem z wersji v9.2.88. \cite{thrust}


\subsubsection{\large Implementacja wielowątkowa}
W implementacji wykorzystuje dwie szablonowe struktury z biblioteki Thrust.
\textbf{host\_vector}\cite{thrust} jest odpowiednikiem \textbf{std::vector}. Rezyduje w pamięci hosta powiązanego z równoległym devicem. \textbf{device\_vector}\cite{thrust} różni się tym, że jest przechowywany w pamięci device'a. Implementacje podzielimy na dwie funkcje.\\
\bigskip

Funkcja NaiveSimBridge, przedstawiona w listingu 2, przyjmuje jako argument \textbf{host\_vector} z pozycjami wszystkich elementów symulacji, a następnie kopiuje go do \textbf{device\_vector} dla odowiedzialnego za transport pozycji ciał do pamięci device'a. \\Następnie w liniach 3-5 konwertuje \textbf{device\_vector} dla pozycji, prędkości i masy do raw pointerów. Wykorzystywane są w 6 linii, w której wywołujemy kernel NaiveSim. W potrójnych nawiasach specyfikujemy liczbę bloków oraz liczbę wątków w każdym bloku(jest to składnia z CUDA Runtime API \cite{runtimeApi}). 
W linii 7 kopiuje nowe pozycje z device'a do hosta. 
\bigskip
\bigskip
\bigskip

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Bridge pomiędzy główną pętlą a kernelem]
void NaiveSimBridge(host_vector &pos, int numberOfBodies, float dt) {
  thrust::device_vector<float> posD = pos;
  float *d_positions = thrust::raw_pointer_cast(posD.data());
  NaiveSim<<<numberOfBlocks, threadsPerBlock>>>(d_positions, 
  	d_velocities, d_weights, numberOfBodies, dt);
  pos = posD;
}
\end{lstlisting}

\bigskip
\bigskip
Kernelem nazywamy funkcję, którą możemy uruchomić dla wielu wątków w pamięci device'a. W tym przypadku kernel NaiveSim, ukazany w listingu 3, jest odpowiedzialny za wyznaczenie nowej pozycji dla każdego ciała. \\
\bigskip

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kernel NaiveSim]
const double G = 6.674 * (1e-11);
template <typename T>
__global__ void 
NaiveSim(T *pos, T *velo, T *weigh, int numberOfBodies, double dt) 
{
  int thid = blockIdx.x * blockDim.x + threadIdx.x;
  if(thid>=numberOfBodies) return;
  double pos[3] = {pos[thid*3], pos[thid*3+1], pos[thid*3+2]};
  double weighI = weigh[thid];
  double force[3] = {0.0, 0.0, 0.0};
  
  for j in {0..numberOfBodies-1}
  {
    if (j != thid) {
      double d[3];
      for(int k=0; k<3; k++) 
        d[k] = pos[j*3 + k] - pos[k];
      float dist = (d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);
      dist = dist*sqrt(dist);
      float F = G * (weighI * weigh[j]);
      for(int k=0; k<3; k++)
        force[k] += F * d[k] / dist;	
    }
  }
  for k in {0..2}
  {
    float acc = force[k] / weighI;
    pos[thid*3+k] += velo[thid*3+k]*dt + acc*dt*dt/2;
    velo[thid*3+k] += acc*dt;
  }
}
\end{lstlisting}
\bigskip

W sygnaturze kernela widzimy, że przyjmuje trzy raw\_pointery do odpowiednio pozycji, prędkości oraz mas. A poza tym dostaje również  odcinek czasu, w którym wykonywany jest dany krok oraz całkowitą liczbę ciał w symulacji. W 6 linii wyznaczamy indeks obiektu, dla którego będziemy prowadzić obliczenia. Jako że korzystamy tylko z jednowymiarowego schematu bloków, to wystarczy wymnożyć identyfikator bloku z rozmiarem pojedynczego bloku oraz dodać identyfikator wątku w bloku. (W każdym kolejnym kernelu $thid$ będzie liczony tak samo).
W linii 7 mamy zabezpiecznie na wypadek gdyby obiekt o takim indeksie nie istniał, gdyż czasami liczba wywołanych wątków jest większa niz rzeczywista liczba obiektów. \\
\bigskip
Dalej mamy część, dla której równoleglimy nasz algorytm. Najpierw w liniach 12-23 mamy pętlę, w której liczymy siłę działającą na obiekt o identyfikatorze, który jest równy wcześniej wyliczonemu thid(threadId) poprzez każdy inny obiekt w symulacji. Postępujemy zgodnie ze wzorem z Prawa 4. W liniach 15-16 wyliczamy wektory odległości między naszym obiektem a każdym innym. W następnych dwóch liniach wyliczamy odległość między tymi dwoma obiektami i podnosimy ją do potęgi trzeciej, tak jak we wzorze. Z kolei w ostatnich liniach tej pętli podstawiamy wszystkie wartości do wzoru, aby obliczyć siłę działającą na ciało. \\
\bigskip
Mając policzoną siłę oddziałującą na obiekt, przechodzimy do wyliczenia nowej pozycji dla obiektu. Jako, że ruch obiektu aproksymujemy poprzez przyjęcie że obiekt w pojedynczmy kroku porusza się ruchem jednostajnym przyśpieszonym, a następnie łączenie ze sobą kolejnych kroków symulacji, to możemy w tym celu wykorzystać wcześniej wprowadzone wzory.\\ Najpierw w linii 25, korzystając z prawa 2, wyliczamy wektor przyśpieszenia ciała. W linii 26 do aktualnej pozycji dodajemy wektor drogi, o którą przesuwamy ciało po obecnym kroku. I w końcu, linia 27 aktualizuje wektor prędkości.
\bigskip

Wykorzystując architekturę CUDA, mogliśmy przyśpieszyć nasz algorytm. Jednakże, symulacja implementowana tym algorytmem ma jeszcze jeden duży problem. Gdy obiekty są bardzo blisko siebie, to znaczy odległość między nimi jest bliska zera, to wtedy siła, którą na siebie działają jest ogromna. Wtedy ciała wyraźnie się oddalają od siebie, co jest nienaturalne.

\subsection{\Large Softening} 

Optymalizacją dla tego problemu jest, tak zwany \textbf{softening}\cite[str.~21]{Aarseth}. Polega na modyfikacji wzoru wprowadzonego w Prawie 4, do następującej postaci:
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j\cdot (r_i - r_j)}{(|r_i - r_j|^2 + \epsilon^{2})^{\frac{3}{2}}},$$ 
gdzie wprowadzony $\epsilon$ ma za zadanie nie dopuścić do bardzo małych odległości w mianowniku wzoru. W pracy przyjąłem, że $\epsilon = 0.01$.

\subsection{\Large Złożoność zrównoleglonej naiwnej wersji algorytmu}
Równoległa wersja naiwnego algorytmu wciąż wykonuje pracę rzędu $\mathcal{O}(N^{2})$, jednakże dzięki temu, że dla każdego obiektu siły na niego działające oraz nową pozycję liczymy na osobnym wątku, to czas działania algorytmu to $\mathcal{O}(N)$, przy założeniu, że mamy do dyspozycji $N$ procesorów.

\section{\LARGE Symulacja N ciał algorytmem Barnes Hut}
Zrównoleglony naiwny algorytm jest szybszy niż wersja jednowątkowa, jednakże wciąż jest zbyt wolny do symulacji układów z bardzo dużą liczbą ciał. W tym celu zaimplementujemy drugi algorytm, zwany algorytmem Barnesa Hut. \cite[str.~446-449]{barnhut}, \cite{barneshut}

\subsection{\Large Drzewa Ósemkowe}

Algorytm jest oparty na drzewach, a dokładniej drzewach ósemkowych \cite{octree}.
Struktura drzewa ósemkowego jest następująca(rys. Figure 2):
\begin{itemize}
  \item w naszym przypadku cała przestrzeń trójwymiarowa jest przedstawiana przez sześcian, który jest reprezentowany przez korzeń drzewa
  \item w klasycznej definicji korzeń drzewa ma ośmioro następników, z których każdy reprezentuje jeden z 8 podsześcianów, na które dzielimy duży sześcian reprezentowany przez korzeń.
  \item każdy z kolejnych wierzchołków w drzewie może mieć 0 następników(gdy nie zawiera żadnego punktu) lub 8 następników.
\end{itemize}

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{tree.pdf_tex}
    \caption{Przykład drzewa ósemkowego z czterema węzłami}
\end{figure}

\subsection{\Large Algorytm Barnes Hut z pseudokodem}
Algorytm Barnes-Hut możemy podzielić na dwie części:
\begin{itemize}
  \item pierwszą z nich jest stworzenie drzewa ósemkowego, które będzie reprezenotwało przestrzeń, w której obecne będą wszystkie obiekty poddawane symulacji
  \item druga część opiera się na przejściu drzewa dla każdego z obiektów i policzenie siły działającej na niego
\end{itemize}
W podstawowej wersji algorytmu obie te części możemy zaimplementować rekurencyjnie.

\subsection{\Large Tworzenie drzewa}
Poniżej pokażemy pseudokod jednowątkowego tworzenia drzewa ósemkowego. Najpierw przedstawmy strukturę węzła w naszym drzewie. Jest to ukazane w poniższym listingu.

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Struktura węzła w drzewie ósemkowym]
struct NodeBH {
    double mass;
    double totalMass;
    bool hasPoint;
    bool childrenExists;
    std::array<double, 6> boundaries;
    std::array<double, 3> pos;
    std::array<double, 3> centerOfMass;
    std::array<NodeBH*, 8> quads;
};
\end{lstlisting}

Żeby nie tworzyć dwóch osobnych struktur dla węzłów wewnętrznych i zewnętrznych połączyliśmy wszystko w jedną strukturę. Przez to nasza struktura musi zawierać masę ciała oraz jego położenie w przestrzeni(tablica pos). Dodatkowo posiada także pola, które mówią o tym czy jest węzłem wewnętrznym czy zewnętrznym oraz czy posiada punkt(czy jest pusty), a także tablicę z granicami sześcianu, to jest jaki fragment przestrzeni jest ograniczony przez węzeł.\\
\bigskip
Jednakże najważniejszymi polami tej struktury są tablica kwadrantów, czyli ośmiu mniejszych węzłów następników na które dzielimy naszą przestrzeń. \\ A także środek masy oraz całkowita masa punktów w przestrzeni określanej przez ten węzeł. 
\textbf{Środek masy(barycentrum) ciała}  jest punktem w przestrzeni, który zachowuje się tak, jak gdyby w nim skupiona była cała masa układu ciał. Jest zadany następującym wzorem:
$$ x_{srm} = \frac{\sum_{j=1}^N m_j\cdot x_j}{\sum_{j=1}^N m_j},$$ gdzie $m_j$ oznacza masę $j$-tego ciała, $x_j$ oznacza jego $x$-ową współrzędną (dla dwóch pozostałych wzory są analogiczne). \\

\subsubsection{\large Funkcja CreateTree}
Poniższy listing przedstawia główną funkcję, która odpowiada za stworzenie drzewa ósemkowego dla naszego algorytmu.\\ 
\bigskip
Funkcja ta przyjmuje jako argument tablice z pozycjami wszystkich obiektów. 
Początkowo w linii 2 tworzy następniki dla korzenia drzewa. Następnie w pętli uaktualnia środek masy korzeniowi (linia 6), a potem sprawdza czy punkt nie wyszedł poza całą przestrzeń naszego algorytmu (linia 8). W przypadku, gdy nie wyszedł, wyszukujemy, do którego z następników możemy wstawić nasz punkt (linia 9), a następnie po stworzeniu węzła dla nowego punktu, wstawiamy go do drzewa w linii 11.
\bigskip

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Pseudokod algorytmu tworzenia drzewa ósemkowego]
void CreateTree(vector<double>& positions) {
    root->addQuads(root->getBoundaries());
    for i in {0..numberOfBodies-1}
    {	
    	auto pos = copy(positions[i*3], ..., positions[i*3+2]);	        
        root->addPointToCenterOfMass(weights[i], pos);
        if(root->pointIsInSpace(pos)) 
        {
            int index = root->getIndexOfSubCube(pos);
            NodeBH* node = new NodeBH(weights[i], pos);
            InsertNode(node, root->getSubQuad(index));
        }
    }
}
\end{lstlisting}

\bigskip

\subsubsection{\large Funkcja InsertNode}

W powyższej funkcji wywołujemy funkcję \textbf{InsertNode} dla każdego węzła wstawianego do drzewa. \\
\bigskip
Funkcja ta przyjmuje jako argumenty węzeł $node$, który chcemy wstawić do podprzestrzeni reprezentowanej przez drugi argument, czyli węzeł $quad$.\\ W funkcji tej obsługujemy trzy następujące przypadki:
\begin{itemize}
\item Gdy węzeł jest pusty, wtedy po prostu wstawiamy nowy węzeł w to miejsce. (linie 3-7)
\item Jeśli natknęliśmy się na zewnętrzny wierzchołek drzewa, to musimy zamienić go na węzeł wewnętrzny, stworzyć dla niego osiem następników, a następnie przepchnąć punkt, który do tej pory zawierał do jednego z nich. W dalszej części tego przypadku, musimy wstawić nowy wierzchołek do tej podprzestrzeni, co robimy uaktualniająć środek masy dla korzenia poddrzewa oraz wstawiająć węzeł rekurencyjnie do odpowiedniego poddrzewa. (linie 8-21)
\item Ostatni przypadek obejmuje wewnętrzne węzły, dla których musimy uaktualnić masę o nowy wierzchołek, a potem wstawić go rekurencyjnie do odpowiedniego następnika. (linie 22-33)
\end{itemize}

\subsubsection{\large Złożoność tworzenia drzewa}

\bigskip
\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Wstawianie pojedynczego węzła do drzewa]
void InsertNode(NodeBH* node, NodeBH* quad) 
{
    if(!quad->isPoint() and !quad->wasInitializedSubQuads()) 
    {
        // pusty węzeł
        quad.insertHere(node);
    }
    else if(quad->isPoint() and !quad->wasInitializedSubQuads()
    {
        // zewnętrzny węzeł
        quad->setPoint(false);
        quad->pushPointFromHereLower();
        quad->addPointToCenterOfMass(node->getMass(), 
            node->getPositions());
        if(quad->pointIsInQuad(node->getPositions());
        {
            int index = int index = quad->getIndexOfSubCube(
                node->getPositions());
            InsertNode(node, quad->getSubQuad(index));
        }
    }
    else if(!quad->isPoint() && quad->wasInitializedSubQuads())
    {
        // wewnętrzny węzeł
        quad->updateCenterOfMass(node->getMass(), 
            node->getPositions());
        if(quad->pointIsInQuad(node->getPositions());
        {
            int index = int index = quad->getIndexOfSubCube(
                node->getPositions());
            InsertNode(node, quad->getSubQuad(index));
        }
    }
}
\end{lstlisting}

\section{\LARGE Zrównoleglenie algorytmu Barnes Hut}

W celu przyśpieszenia algorytmu poprzez wielowątkową implementaję, musimy zmienić nasze podejście w tworzeniu drzewa. Obecny pomysł się nie sprawdzi, ponieważ poszczególne wierzchołki są doklejane sekwencyjnie jako dzieci do innych wierzchołków, przez co nie możemy tego zrealizować równolegle.
Aby podjąć wyzwanie równoległej implementacji drzew ósemkowych, musimy przed rozpoczęciem konstruowania drzewa mieć informację o położeniu każdego wierzchołka w drzewie.

\subsection{\Large Kody Mortona}
W tym celu zastosujemy \textbf{kody Mortona}.
Kodami Mortona, nazywamy mapowanie punktu w przestrzeni do listy liczb(w naszym przypadku mapujemy punkty w 3-wymiarowej przestrzeni do liczb całkowitych, a konkretniej interesowć nas będzie ich bitowa reprezentacja).
Porządek Mortona jest definiowany przez \textbf{space-filling curve}, która jest w kształcie \textbf{Z}, więc czasami jest nazywana \textbf{Z-curve}. Krzywa ta ma ważną własność - jeśli elementy są blisko siebie w drzewie, to w tym porządku ta bliskość jest zachowana w ułożeniu w pamięci. W pracy traktujemy kod Mortona jako 64-bitową liczbę całkowitą, w której 20 bitów (łącznie 60 dla wszystkich trzech wymiarów) oznacza kolejne rozgałęzienia dla naszego węzła, czyli jedną z dwóch części, w których punkt kolejno ląduje, gdy umieszczamy go w coraz mniejszych sześcianach, aż do przyjętej głębokości równej 20.

\begin{figure}[h]
    \centering      
    \def\svgscale{0.53}
    \input{zcurve.pdf_tex}
    \caption{Przykład Z-curve}
    \label{fig:krzywa}
\end{figure}


\subsection{\Large Równoległa implementacja drzew ósemkowych}
Z wykorzystaniem powyżej zdefiniowanych kodów będziemy implementować algorytm wspomniany w pracy Tero Karrasa \cite{tero}, z tym wyjątkiem, że będzie lekko zmodykifowany, gdyż nie będziemy korzystać z wprowadzonych tam \textbf{binary radix tree}.

Zmodyfikowany algorytm (skrótowo) składa się z sześciu kroków :
\begin{itemize}
\item Obliczenie kodów Mortona dla każdego węzła. Realizujemy to poprzez kernel, który na podstawie przedziałów, w których zawierają się punkty w całym układzie dla każdego z wymiarów(znajdujemy dolną i górną granicę w każdym z wymiarów), wyznacza przez 20 poziomów coraz to dokładniejsze położenie poprzez ustawianie kolejnych bitów w liczbie binarnej. 
\item Sortujemy kody Mortona. W tym celu wykorzystujemy bibliotekę Thrust, a dokładniej funkcję \textbf{sort\_by\_key}. 
\item Kody liczymy do głębokości 20, więc istnieje możliwość pojawienia się duplikatów, których tyczą się dwie kolejne części naszego algorytmu (zidentyfikowanei i usunięcie duplikatów). W naszej implementacji załatwiamy to kolejną funkcją z biblioteki thrust, to jest \textbf{unique\_by\_key}.
\item Liczymy ile wierzchołków będzie miało nasze drzewo(znamy jedynie liczbę liści, potrzebujemy policzyć również liczbę węzłów wewnętrznych. Dodatkowo tworzymy wierzchołki.
\item  Łączymy węzły według relacji (rodzic, dziecko). W tym celu musimy odpowiednio przyporządkować każdemu węzłowi jego węzeł nadrzędny.
\end{itemize}

\subsection{\Large Pseudokody poszczególnych kroków}
W tym rozdziale przedstawimy pseudokody do kolejnych kroków algorytmu.
\subsubsection{\large Liczenie kodów Mortona}
\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Krok 1]
__global__
void calculateMortonCodes(T* pos, long long* codes, int numberOfBodies, T* mins, T* maxs) {
  float start[3] = {mins[0], mins[1], mins[2]};
  float middle[3] = {(maxs[0] - mins[0])/2, (maxs[1] - mins[1])/2, (maxs[2] - mins[2])/2};
  unsigned long long code = 0;
  for i in {0..K-1} 
  {
  	for j in {0..2}
    {
      code <<= 1;
      if(start[j] + middle[j] < pos[3*thid + j]) {
        code |= 0x1;
        start[j] += middle[j];
      }
      middle[j] /= 2;
    }
  }
  codes[thid] = code;
}
\end{lstlisting}
W przypadku liczenia kodów Mortona, potrzebujemy minimalnego oraz maksymalnego punktu w każdym z wymiarów. Dzięki temu jesteśmy w stanie wyznaczyć początek oraz środek przedziału dla obiektu na danej głębkości. Poprzez to możemy stwierdzić, w której połowie znajduje się nasz obiekt(czyli na danej głębokości przydzielić 0 lub 1).
\subsubsection{\large Sortowanie oraz usunięcie duplikatów w kodach}

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kroki 2-4]
thrust::device_vector<int> sortedNodes(numberOfBodies);
int* d_sortedNodes = thrust::raw_pointer_cast(sortedNodes.data());
fillNodes<<<blocks, THREADS_PER_BLOCK>>>(d_sortedNodes, numberOfBodies);

thrust::sort_by_key(mortonCodes.begin(), mortonCodes.end(), sortedNodes.begin());  
  
iterators = thrust::unique_by_key(mortonCodes.begin(), mortonCodes.end(), sortedNodes.begin());
\end{lstlisting}

Rolą wektora sortedNodes jest zachowanie początkowej numeracji punktów, to znaczy sortujemy pary \textbf{(kodMortona, początkowyIndeks)}.
Zmienna iterators dostaje parę iteratorów na posortowane wektory jako wynik z \textbf{thrust::unique\_by\_key}.

\subsubsection{\large Zliczenie węzłów wewnętrznych oraz łączenie węzłów}

Dwie ostatnie części budowania drzewa opiszemy w jednym podrozdziale.
Zacznijmy od przedstawienia struktury odpowiedzialnej za węzły w naszym drzewie:

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Struktura OctreeNode]
struct OctreeNode {
  int children[8];
  int position;
  float totalMass;
  float centersOfMass[3];
};
\end{lstlisting}
W powyższej strukturze przechowujemy indeksy następników w globalnej tablicy węzłów, a także standardowo całkowitą masę poddrzewa oraz środek masy. Dodatkowo mamy pole position, które przyjmuje -1, gdy węzeł jest wewnętrzny oraz indeks węzła(wejściowy), gdy węzeł jest liściem.
Jak widzimy niżej, początkowo tworzymy \textbf{device\_vector} dla węzłów o liczbie elementów, którą wyznacza liczba punktów z wejścia, które mają unikalne kody Mortona. \\
Tworzymy również wektor, którego zadaniem jest przechowywanie informacji o rodzicu każdego z wezłów (informacja ta będzie niezbędna przy łączeniu wierzchołków) na każdym z poziomów (jak wspomnieliśmy nasze drzewo ma 20 poziomów). Poniższy fragment kodu zawiera również trzy istotne zmienne:
\begin{itemize}
\item \textbf{childrenCount} - zlicza liczbę nowych węzłów na każdym z poziomów drzewa
\item \textbf{previousChildrenCount} - przechowuje liczbę węzłów z poprzedniego poziomu
\item \textbf{allChildrenCount} - zlicza liczbę wszystkich węzłów w drzewie ósemkowym
\end{itemize}

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Przechowywanie węzłów drzewa]
thrust::device_vector<OctreeNode> octree(uniquePointsCount);
OctreeNode* d_octree = thrust::raw_pointer_cast(octree.data());
	
thrust::device_vector<int> parentsNumbers(uniquePointsCount);
int* d_parentsNumbers = thrust::raw_pointer_cast(parentsNumbers.data());
int childrenCount = uniquePointsCount;
int allChildrenCount = uniquePointsCount;
int previousChildrenCount = 0;
\end{lstlisting}

Kluczowym punktem tych dwóch części jest poniższa pętla. Iteruje się ona $K=20$ razy, zaczynając od dzieci drzewa(podejście \textbf{bottom-up}), oznacza to także, że zaczyna od węzłów ograniczających najmniejszy obszar, czyli ograniczającego nasze punkty najdokładniej.\\
W każdej z iteracji chcemy wyznaczyć rodziców dla węzłów. \\W tym celu pomocny jest kernel \textbf{calculateDuplicates} w połączeniu z \textbf{thrust::inclusive\_scan}, które pozwalają wyznaczyć duplikaty wśród rodziców(czyli węzły, które są poprzednikami dla więcej niż kilku węzłów na niższym poziomie). 
Kernel ustawia w wektorze $1$, jeśli rodzice dwóch kolejnych węzłów są różni (wystarczy sprawdzić dwa kolejne, gdyż dzięki sortowaniu dzieci jednego węzła są obok siebie), a następnie $scan$ robi sumę prefiksową tej tablicy, aby wyznaczyć te, które są takie same(mają przypisane takie same liczby po $scanie$).

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kernel calculateDuplicates]
__global__
void calculateDuplicates(unsigned long long* mortonCodes, int* result, int N) {
  int thid = blockIdx.x*blockDim.x + threadIdx.x;
  if(thid >= N || thid == 0) return;
  unsigned long long code = mortonCodes[thid];
  unsigned long long previous_code = mortonCodes[thid-1];
  code >>= 3;
  previous_code >>= 3;
  result[thid] = (code != previous_code);
}

\end{lstlisting}
\bigskip
Po wyznaczeniu nowych wierzchołków na kolejnym poziomie, wstawiamy je do wektora \textbf{octree}, a następnie przesuwamy im indeks, aby miały indeksy zaczynające się od pierwszego numera po ostatnim węźle z poziomu niżej. Widzimy, że tym sposobem \textbf{root} drzewa będzie ostatnim węzłem w naszej tablicy.

Kiedy stworzymy węzły na danym poziomie, to następnym zadaniem jest połączenie ich z niższym poziomem. Relizujemy to poprzez kernel \textbf{connectChildren}.
\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kernel connectChildren]
__global__
void connectChildren(unsigned long long int* mortonCodes, int* parentsNumbers, OctreeNode* octree, 
    int N, int previousChildrenCount, int* sortedNodes, int level) {
  unsigned long long childNumber = mortonCodes[thid]&0x7;
  octree[parentsNumbers[thid]].children[childNumber] = thid+previousChildrenCount;
  octree[thid+previousChildrenCount].position = level == 0 ? sortedNodes[thid] : -1;
  octree[parentsNumbers[thid]].totalMass += octree[childNumber].totalMass;
  octree[parentsNumbers[thid]].centersOfMass = updateCentersOfMass(parentsNumbers[thid], 
  	childNumber);
}
\end{lstlisting}

Cele, które ten kernel realizuje, są następujące:
\begin{itemize}
\item ustawienie odpowiedniego dziecka (informacja z kodu Mortona),
\item ustawienie pola position, to znaczy -1 gdy węzeł wewnętrzny, w przeciwnym przypadku identyfikator węzła,
\item aktualizacja totalMass dla węzła,
\item aktualizacja centersOfMass dla węzła. 
\end{itemize}

Całą pętlę realizującą kroki piąty oraz szósty, przedstawia poniższy pseudokod:
\newpage
\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kroki 5-6]
for(int i = 0; i < K; ++i) {
        blocks = (childrenCount+THREADS_PER_BLOCK-1)/THREADS_PER_BLOCK;
        thrust::fill(parentsNumbers.begin(), parentsNumbers.end(), 0);
        calculateDuplicates<<<blocks, THREADS_PER_BLOCK>>>(
            d_codes, d_parentsNumbers, childrenCount);
        
        thrust::inclusive_scan(parentsNumbers.begin(), parentsNumbers.end(), parentsNumbers.begin());

        octree.insert(octree.end(), parentsNumbers[childrenCount-1]+1, OctreeNode());
        d_octree = thrust::raw_pointer_cast(octree.data()); 
        
        thrust::for_each(parentsNumbers.begin(), parentsNumbers.end(), 
        	thrust::placeholders::_1 += allChildrenCount);
        
        connectChildren<<<blocks, THREADS_PER_BLOCK>>>(
            d_codes, d_parentsNumbers, d_octree, childrenCount, 
            previousChildrenCount, d_sortedNodes, i
        );
        
        thrust::for_each(mortonCodes.begin(), mortonCodes.end(), thrust::placeholders::_1 >>= 3);
        auto it = thrust::unique(mortonCodes.begin(), mortonCodes.end());
        childrenCount = thrust::distance(mortonCodes.begin(), it);
        previousChildrenCount = allChildrenCount;
        allChildrenCount += childrenCount;
    }
\end{lstlisting}

\section{\LARGE Liczenie sił oddziałujących na ciało}

Drzewo zostało stworzone w celu szybszego liczenia siły jaka działa na ciało.\\
Wersje jednowątkowa oraz wielowątkowa do liczenia siły różnią się jedynie tym, że ta druga robi to na osobnym wątku dla każdego ciała. Przedstawimy więc jedynie wielowątkowe podejście. \\
Algorytm polega na przejściu drzewa od korzenia i na sprawdzaniu czy węzeł jest wewnętrzny czy zewnętrzny. Gdy węzeł jest liściem, to zwyczajnie liczymy siłę między naszym punktem a tym węzłem (jak w naiwnym algorytmie). Gdy węzeł jest wewnętrzny, to potrzebujemy następującej definicji \cite{Aarseth}:

\theoremstyle{definition}
\begin{definition}{Ratio}
- niech s będzie szerokością obszaru obejmowanego przez sześcian oraz niech d będzie odległością między środkiem masy obszaru a punktem, to jeśli $s/d < \Theta$, wtedy liczymy siłę między środkiem masy obszaru a punktem. W przeciwnym przypadku wywołujemy się rekurencyjnie na ośmiu podsześcianach.
\end{definition}

Powyższa definicja wyjaśnia postępowanie dla wewnętrznego węzła. Dodatkowo musimy rostrzygać czy nasz punkt i przetwarzany węzeł nie są tym samym węzłem, aby nie liczyć siły między nimi.\\~\\~\\
\bigskip
\bigskip

\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}} 
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Liczenie siły oddziałującej na ciało w układzie]
__global__
void computeForces(OctreeNode* octree, float* forcesGlobal, float* velocities, float* weights, 
	float* pos, int AllNodes, int N, float dt) 
{	
    float forces[3] = {0.0, 0.0, 0.0};
    OctreeNode* node;
    float p = {pos[3*thid], pos[3*thid + 1], pos[3*thid + 2]);
    forces[thid] = 0.0;
    unsigned long long int stack[64];
    int top = -1;
    stack[++top] = AllNodes-1;
    while(top>=0) 
    {
    	node = octree[idx];
        int idx = stack[top--];
        if(noe->position == -1)
        {
            double d = dist(node->getCenterOfMass(), p);
            double s = boundaries[1] - boundaries[0];
            bool isFarAway = (s/d < theta);
            if(isFarAway)
            {	
                for k in {0..2}
                    forces[3*thid + k] += forcesBetween(node->getCenterOfMass(), p);
            }
            else
            {
                for i in {0..numberOfChilds-1}
                {
                    stack[++top] = node->children[i];
                }
            }
        }
        else
        {
            if(thid == octree[idx].position) 
                continue;
            for k in {0..2}
                forces[3*thid + k] += forcesBetween(node->getPoint(), p);
        }	
    }
    for k in {0..2}
    	forcesGlobal[3*thid+k] = forces[k];
    UpdatePositionAndVelocity(forces, positions, velocities, weights, N, dt);
}
\end{lstlisting}

\section{\LARGE Wizualizacja}
	
W celu wizualizacji symulacji wykorzystałem OpenGL3. 

\subsection{\large OpenGL}
OpenGL \cite{opengl} jest API, które jest przeznaczone głównie do tworzenia grafiki. OpenGL wykorzystuje kartę graficzną (GPU), więc tworzenie grafiki następuje szybciej niż innymi sposobami. Ten efekt nazywamy przyspieszeniem sprzętowym. OpenGL wykorzystywany jest często przez gry komputerowe i wygaszacze ekranu.

\subsection{\large Renderowanie symulacji}

Najistotniejszym punktem kodu OpenGL-owego jest rysowanie symulacji w każdym kroku, za które odpowiada funkcja \textbf{Render}:
\lstset{backgroundcolor=\color{white}, basicstyle=\footnotesize\fontfamily{fvm}\selectfont, numbers=left, numbersep=8pt, keywordstyle=\color{blue},commentstyle = \color{mygreen}}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Pseudokod renderowania symulacji]
void Render() 
{
    glUseProgram(program);
    glm::mat4 view = glm::lookAt(
        glm::vec3(
        camera_radius*sin(camera_theta),
        camera_radius*cos(camera_theta)*cos(camera_phi),
        camera_radius*cos(camera_theta)*sin(camera_phi)
        ),
        glm::vec3(0, 0, 0),
        glm::vec3(0, 1, 0)
    );
    glm::mat4 projection = glm::perspective(
        glm::radians(45.0f),
        1.0f*width/height,
        0.1f,
        100.0f
    );
    glm::mat4 mvp = projection * view;
    GLuint MatrixID = glGetUniformLocation(program, "MVP");
    glUniformMatrix4fv(MatrixID, 1, GL_FALSE, &mvp[0][0]);
    
    UpdateBuffers();
    DrawPoints();
}
\end{lstlisting}
\bigskip

Render polega głównie na wykorzystaniu macierzy Model-View-Projection (MVP) \cite{tutMat}. 
W linii 19 wymnażamy wszystkie macierze ze sobą (odpowiedzialnego za każdy z kroków MVP), uzyskując wyrenderowaną pozycję naszych obiektów).\\

Bardziej szczegółowo, najpierw ustawiamy kamerę, do czego służy funkcja \textbf{lookAt} \cite{opengl}, która jako pierwszy argument przyjmuje współrzędne kamery, następnie punkt na który patrzymy, a w ostatnim parametrze ustawiamy, że patrzymy z góry do dołu.\\
Z kolei funkcja \textbf{perspective} \cite{opengl} odpowiada za rzutowanie, a w argumentach przyjmuje:
\begin{itemize}
\item kąt z jakiego patrzymy na punkt podany w radianach
\item \textbf{aspect rato}, czyli proporcje pomiędzy szerokością i wysokością obrazu
\item \textbf{far clipping plane} oraz \textbf{near clipping plane}, które wyznaczają płaszczyzny, które ograniczają obszar renderowania
\end{itemize} 

\newpage

\section{\LARGE Podsumowanie}

W pracy zaimplementowałem cztery algorytmy:
\begin{itemize}
\item Jednowątkowy naiwny algorytm (złożoność $\mathcal{O}(N^{2})$)
\item Wielowątkowy naiwny algorytm (złożoność $\mathcal{O}(N) $ przy $N$ procesorach, wykonana praca $\mathcal{O}(N^{2})$
\item Jednowątkowy algorytm Barnes Hut (złożoność $\mathcal{O}(N\cdot \log(N))$
\item Wielowątkowy algorytm Barnes Hut (złożoność $\mathcal{O}(\log(N))$ przy $N$ procesorach, wykonana praca $\mathcal{O}(N\cdot \log(N))$
\end{itemize}

Poniżej przedstawiam wykres przedstawiający czas wykonywania się poszczególnych algorytmów przy jednakowych danych wejściowych oraz przez identyczną liczbę kroków. W testach algorytmy były odpalane przez $100000$ kroków.

\begin{figure}[h]
\begin{tikzpicture}
\begin{axis}[
    title={Porównanie czasu działania algorytmów},
    xlabel={Rozmiar kernela},
    ylabel={Czas (ms)},
    xmin=0, xmax=128,
    ymin=0, ymax=1500,
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (1,161.25)(3,207.22)(5,238.25)(7,345.54)(9,425.62)(11,469.78)(13,648.63)(15,786.14)(17,909.76)(19,1046.35)(21,1192.08)(23,1402.21)(25,1620.54)(27,1864.30)(29,2090.17)(31,2388.40)
    };
\addplot[
    color=red,
    mark=square,
    ]
    coordinates {
    (1, 168.2)(3, 170.0)(5, 179.5)(7, 247.0)(9, 263.5)(11, 233.9)(13, 218.7)(15, 234.0)(17, 252.5)(19, 298.3)(21, 298.5)(23, 326.6)(25, 356.8)(27, 397.7)(29, 440.5)(31, 473.1)(33, 529.1)(35, 550.0)(37, 624.0)(39, 645.6)(41, 686.7)(43, 748.7)(45, 805.1)(47, 852.9)(49, 917.5)(51, 983.1)(53, 1045.1)(55, 1106.3)(57, 1206.3)(59, 1255.6)(61, 1341.2)(63, 1409.4)
    
    };
\addplot[
    color=green,
    mark=square,
    ]
    coordinates {
    	(1, 208.3)(3, 209.2)(5, 221.7)(7, 200.6)(9, 198.4)(11, 199.1)(13, 239.2)(15, 240.1)(17, 199.0)(19, 255.5)(21, 213.7)(23, 200.3)(25, 235.2)(27, 233.1)(29, 202.1)(31, 203.8)(33, 205.0)(35, 211.1)(37, 235.6)(39, 221.2)(41, 231.9)(43, 258.1)(45, 238.7)(47, 231.8)(49, 240.3)(51, 234.0)(53, 276.5)(55, 276.5)(57, 227.0)(59, 235.0)(61, 265.1)(63, 227.8)(65, 280.7)(67, 249.1)(69, 240.7)(71, 236.3)(73, 256.4)(75, 257.1)(77, 242.7)(79, 292.0)(81, 258.2)(83, 250.4)(85, 248.1)(87, 302.7)(89, 278.7)(91, 294.4)(93, 262.8)(95, 305.1)(97, 295.0)(99, 314.4)(101, 289.2)(103, 309.0)(105, 293.3)(107, 265.5)(109, 322.2)(111, 295.1)(113, 294.8)(115, 269.9)(117, 291.9)(119, 329.9)(121, 311.2)(123, 315.8)(125, 279.2)(127, 335.9)
    };
\legend{Naiwna implementacja, Zoptymalizowana konwolucja, Separable convolution}
\end{axis}
\end{tikzpicture}
\caption{Porównanie czasu działania algorytmów}
\end{figure}

Z tego co możemy wywnioskować, to że czas wykonywania się obu implementacji algorytmu Barnes Hut maleje, gdy liczba kroków wzrasta. Dzieje się to z powodu, że gdy obiekty zmienią pozycję względem tych początkowych, to część z nich oddala się względem innych obiektów i przez to często grupka obiektów jest traktowana jako jeden obiekt i nie musimy liczyć siły z każdym z osobna, a za to liczymy siłę tylko raz z środkiem masy tej grupki ciał. Z tego co widzimy, to zdecydowanie przyśpiesza algorytm względem naiwnych implementacji.
\newpage

\nocite{*}
\printbibliography%[title=\foreignlanguage{polski}{Bibliografia}]

\end
{document}
