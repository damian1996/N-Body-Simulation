\documentclass[14pt,twoside,a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{blindtext}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{caption}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fontenc}
\usepackage[document]{ragged2e}
\usepackage{bm}
\usepackage{pstricks}
\usepackage{auto-pst-pdf}
\usepackage{hyperref}
\usepackage[
backend=biber,
style=alphabetic,
]{biblatex}
\addbibresource{biblio.bib}
\hypersetup{
  colorlinks, linkcolor=black, citecolor=red
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\newtheorem{theorem}{Prawo}
\newenvironment{myproof}[2] {\paragraph{Dowód:}}{\hfill$\square$}
\newcommand\tab[1][1cm]{\hspace*{#1}}

%\geometry{left=2.5cm,right=2.5cm,top=10.0cm,bottom=2.5cm}
\begin{document}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	
	\center
	
	\textsc{\Large Uniwersytet  Jagielloński\\
			 Wydział Matematyki i Informatyki\\
    		 Zespół Katedr i Zakładów Informatyki Matematycznej}\\[1.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\HRule\\[0.4cm]
		
	{\huge\bfseries Wielowątkowa symulacja N ciał z implementacją w architekturze CUDA}\\[0.4cm] % Title 
	
	\HRule\\[1.5cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Autor}\\
			Damian Stachura% \textsc{Stachura}  Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Opiekun}\\
			dr Maciej Ślusarek %\textsc{Ślusarek}  Supervisor's name
		\end{flushright}
	\end{minipage}
	
	\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
\end{titlepage}

\newpage
\tableofcontents

\newpage

\section{\LARGE Przedstawienie problemu symulacji N ciał}
\bigskip
Symulacja N ciał jest zagadnieniem z mechaniki klasycznej, które polega na wyznaczeniu toru ruchów wszystkich ciał danego układu o danych masach, prędkościach i położeniach początkowych w oparciu o prawa ruchu i założenie, że ciała oddziałują ze sobą zgodnie z prawem grawitacji Newtona. \\

\subsection{\Large Szczególne przypadki}
\bigskip
Problem wyznaczenia dokładnego ruchu dowolnej liczby ciał jest trudny, więc można znaleźć wiele prac skupiająych się jedynie na ustalonej, małej liczbe ciał.

\subsubsection{Problem dwóch ciał}
Problem dla dwóch ciał podlegających prawom klasycznej dynamiki Newtona i przyciągających się zgodnie z newtonowskim prawem powszechnego ciążenia został rozstrzygnięty przez J. Bernoulliego przy założeniu, że masa obiektu koncentruje się w jego środku. \cite{fund}

Obydwa ciała poruszają się po krzywych stożkowych, których rodzaj zależy od całkowitej energii układu. Przykładowo, gdy energia jest mała, to ciała nie mogą się od siebie uwolnić, więc krążą wokół siebie po elipsach.

\subsubsection{Problem trzech ciał}
Problem trzech ciał wciąż nie został rozwiązany w ogólności. Jednakże istnieją rozwiązania dla szczególnych przypadków, jak na przykład \cite{threebody1, threebody2}. Inną wariacją tego problemu jest system, w którym masa jednego z ciał jest zaniedbywalnie mała, jest to tak zwany ograniczony problem trzech ciał - przedstawiony przez J. L. Lagrange'a w XVIII wieku. Badał on układ Słońce-Ziemia-Księżyc. 


\subsection{\Large Zastosowania}
\bigskip
Symulacje N ciał są szeroko wykorzystywanymi narzędziami w fizyce oraz astronomii. Problemem, w którym symulacje są użyteczne jest na przykład dynamika systemu z kilkoma ciałami jak układ Słońce-Ziemia-Księżyc \cite{SEMmisc}, co może pomóc w zrozumieniu działania olbrzymich systemów we wszechświecie. \cite{chaosMisc}
W kosmologii symulacje są wykorzystywane do studiowania procesów tworzenia nieliniowych struktur jak galaktyczne halo z wpływem ciemnej materii \cite{haloDensity}. 
Z kolei, bezpośrednie symulacje N ciał są wykorzystywane na przykład do studiowania dynamicznej ewolucji klastrów gwiazd lub do symulacji dynamiki planetozymali. \cite{dirNBody}. Symulacje są wykorzystywane, również w innych dziedzinach, chociażby w algorytmach rysowania grafu skierowanego siłą \cite{visGraph}
\newpage

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{draw.pdf_tex}
    \caption{Symulacja dwóch ciał poruszających się po elipsach}
\end{figure}


\subsection{\Large Implementacja i wykorzystane technologie}
W pierwszej części mojej pracy przedstawię równoległą implementację naiwnego algorytmu symulacji N ciał. W każdym kroku algorytm bezpośrednio wyznacza siły oddziałujące wzajemnie pomiędzy każdymi dwoma ciałami w systemie, czyli wyznacza siłę jaką pozostałe obiekty działają na wybrany. W drugiej części zaimplementuję wielowątkowo algorytm Barnes Hut'a, który korzysta z drzew ósemkowych.

Repozytorium jest dostępne pod tym \href{https://github.com/damian1996/N-Body-Simulation}{linkiem}.
Całość została zaimplementowana w C++. Poniżej wymienione są pozostałe technologie wykorzystane w projekcie. \\
Pełna instalacja niezbędnego oprogramowania do uruchomienia symulacji jest zawarta w repozytorium (dla linuxa Ubuntu).
\subsubsection{\large Architektura CUDA}
CUDA to uniwersalna architektura procesorów wielordzeniowych (głównie kart graficznych) umożliwiająca zaimplementowanie ich mocy obliczeniowej w wielu problemach, które mogą się wykonywać zarówno sekwencyjne i wielowątkowo. Wykorzystałem CUDĘ w wersji v9.1.85 do paralelizacji dwóch wspomnianych powyżej algorytmów.
\subsubsection{\large Thrust}
Thrust jest szablonową biblioteką dla CUDA bazująca na bibliotece STL z C++. Thrust umożliwia implementację aplikacji wielowątkowych za pośrednictwem interfejsu wysokiego poziomu, który jest w pełni zgodny z CUDA C. Korzystałem z wersji v9.2.88. 
\subsubsection{\large OpenGL}
OpenGL jest API do tworzenia grafiki. Skorzystałem z OpenGL3, w celu zwizualizowania symulacji w 3D.


\section{\LARGE Pierwsze podejście implementacyjne}
\bigskip

\subsection{\Large Sformułowanie problemu}
W celu przedstawienia ogólnego sformułowania problemu potrzebujemy przytoczyć trzy prawa dynamiki sformułowane przez Isaaca Newtona \cite{fund}

\begin{theorem}
Każde ciało pozostaje w stanie spoczynku lub ruchu jednostajnego w linii prostej, chyba że jest zmuszone zmienić ten stan przez zewnętrzne oddziaływanie z innymi ciałami, czyli każde ciało jest w układzie inercjalnym.
\end{theorem}

\begin{theorem}
Szybkość zmiany pędu jest proporcjonalna do siły wywieranej i znajduje się w tym samym kierunku co siła.
\end{theorem}
Co oznacza, że w inercjalnym układzie odniesienia zachodzi równość $F=ma$, gdzie $F$ jest wektorem sum sił działających na obiekt, $m$ to masa obiektu, $a$ to jego przyśpieszenie.

\begin{theorem}
Każdej akcji towarzyszy reakcja równa co do wartości i kierunku, lecz przeciwnie zwrócona.
\end{theorem} 
Co oznacza, że jeśli ciało A działa na ciało B siłą F (akcja), to ciało B działa na ciało A siłą (reakcja) o takiej samej wartości i kierunku, lecz o przeciwnym zwrocie.\\~\\


Niezbędne jest również przytoczenie prawa powszechnego ciążenia Newtona \cite{fund}
\begin{theorem}
Każdy obiekt przyciąga każdy inny obiekt z siłą, która jest wprost proporcjonalna do iloczynu ich mas i odwrotnie proporcjonalna do kwadratu odległości między ich środkami.
\end{theorem}
Czyli między dowolną parą ciał posiadających masy pojawia się siła przyciągająca, która działa na linii łączącej ich środki, a jej wartość rośnie z iloczynem ich mas i maleje z kwadratem odległości.\\~\\

Aplikując to prawo do symulacji N ciał, uzyskujemy że na każde $i$-te ciało działa siła $F_i$ zdefiniowana następująco:\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$gdzie $G$ to stała grawitacji, $m_i$ masa ciała na które oddziałują inne ciała, $m_j$ masa ciała oddziałującego na $i$-te ciało, $r_i - r_j$ to różnica wektorów pozycji dwóch ciał, $|r_i - r_j|$ to dystans między ciałami. \\~\\
Z wykorzystaniem powyższych praw możemy podać następującą definicję
\paragraph{Symulacja N ciał} 
\newcommand{\mi}{\boldsymbol{} \mathrel{\mkern -16mu} \boldsymbol{-}}
$\mi$
Dla N ciał mających ustalone masy oraz początkowe położenie i prędkość, ruch każdego obiektu jest symulowany z wykorzystaniem prawa powszechnego ciążenia oraz poprzez wyznaczenie przyspieszenia obiektu korzystając z drugiego prawa dynamiki Newtona.

\subsection{\Large Jednowątkowy naiwny algorytm z pseudokodem}

Najprostszy algorytm dla problemu N ciał zadany pseudokodem może wyglądać tak:\\

\lstset{
	backgroundcolor=\color{white},
	numbers=left, 
	numbersep=8pt,	
	literate=%
	%	zażółć gęślą jaźń
	{ź}{{\'z}}1
	{ż}{{\.z}}1
	{ń}{{\'n}}1
	{ó}{{\'o}}1
	{ł}{{\l{}}}1
	{ć}{{\'c}}1
	{ą}{{\k{a}}}1
	{ę}{{\k{e}}}1
	{ś}{{\'s}}1
}

\begin{lstlisting}[frame=single, framerule=2pt, caption=pseudokod]
ustaw mase oraz początkową pozycję i prędkość dla każdego ciała
while(true)
   for i in {1...N}:
       uaktualnijPozycje()
   narysujNowePozycje()
\end{lstlisting}


Każde ciało na początku symulacji ma losowaną pozycję, prędkość oraz wagę. Jednostki przyjęte w symulacji są następujące : \\
- jednostką wagi jest masa słońca. Masa słońca jest definiowana następująco\\
\begin{center}
M\textsubscript{\(\odot\)} = 1.9884\(\cdot 10^{30}\)\\
\end{center}
Symulowane gwiazdy mają wagi z zakresu \([0.5, 10]\) M\textsubscript{\(\odot\)}.\\
- jednostką odległości jest parsek, czyli odległość, dla której paralaksa roczna położenia Ziemi widzianej prostopadle do płaszczyzny orbity wynosi 1 sekundę łuku. W przeliczeniu na metry i po zaokrągleniu jest to 
\begin{center}
\(1\) pc \(\approx\) \(3,2616\) roku świetlnego \(\approx\) \(3,086\cdot 10^{16}\) m\\
\end{center}
Najbardziej złożoną operacją w algorytmie jest uaktualnienie pozycji w każdym obiegu pętli nieskończonej dla każdego ciała w symulacji. W tym celu wykorzystane zostało, wcześniej wprowadzone, Prawo 4. W ten sposób może zostać policzona siła, którą na dane ciało działają wszystkie pozostałe obiekty w symulacji. 

Przypominając, wzór na siłe działającą na ciało wygląda następująco :\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$ 
gdzie stała grawitacji wynosi
\begin{center}
$$G = 6,67408(31)\cdot 10^{-11} \frac{m^{3}}{kg s^2},$$
\end{center}
W astronomii stała grawitacji jest wyrażana jako 
\begin{center}
$$G = 4,3\cdot 10^{-3} \frac{pc}{M_{\odot}} \frac{km^2}{s^2}$$
\end{center}
Złożoność obliczeniowa naiwnej operacji uaktualnienia pozycji wszyskich obiektów, przedstawia poniższy fakt.

\begin{theorem}
Uaktualnienie pozycji wszystkich ciał ma złożoność obliczeniową $\mathcal{O}(N^{2})$.
\end{theorem}

\begin{myproof}

\tab Dla każdego ciała najpierw musimy wyznaczyć siłę działającą na nie poprzez interakcję z innymi ciałami, czyli dla każdego z $N$ ciał musimy policzyć siłę oddziałującą nań z każdym innym obiektem, więc musimy policzyć wartość wzoru wynikającego z prawa $4$ $N\cdot N-1$ razy, czyli złożoność tej podoperacji $\mathcal{O}(N^{2})$. 
Następnie dla każdego obiektu musimy wyznaczyć jego przyśpieszenie oraz nową pozycję i prędkość, co jesteśmy w stanie zrobić w czasie $\mathcal{O}(N)$.
Poprzez zsumowanie złożoności obu podoperacji, widzimy że złożoność obliczeniowa jednego kroku symulacji naiwnego algorytmu wynosi $\mathcal{O}(N^{2})$.
\end{myproof}


\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              

\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=uaktualnienie pozycji ciał]
typedef thrust::host_vector<float> tf3;
void StepNaive::compute(tf3& positions, float dt) {
  std::fill(forces.begin(), forces.end(), 0);
  for(unsigned i=0; i<N; i++) {
    for(unsigned j=0; j<N; j++) {
      float distX = positions[j*3] - positions[i*3];
      float distY = positions[j*3+1] - positions[i*3+1];
      if(i!=j && fabs(distX) > 1e-10 && fabs(distY) > 1e-10) {
        float F = G*(weights[i]*weights[j]);
        forces[i*3] += F*distX/(distX*distX+distY*distY);
        forces[i*3+1] += F*distY/(distX*distX+distY*distY);
      }
    }
  }
  for(unsigned i=0; i<N; i++) {
    for(int j=0; j<2; j++) { // x, y
      float acceleration = forces[i*3+j]/weights[i];
      positions[i*3+j] += velocities[i*3+j]*dt + acceleration*dt*dt/2;
      velocities[i*3+j] += acceleration*dt;
    }
  }
}
\end{lstlisting}


\subsection{\Large Paralelizacja naiwnego algorytmu}

\bigskip
\subsection{\Large Implementacja}

\bigskip

\section{\LARGE Drugie podejście}

\bigskip

\subsection{\Large Algorytm Barnesa-Huta z pseudokodem}

\bigskip

\subsection{\Large Zrównoleglenie algorytmu Barnesa-Huta}

\bigskip
 sudo apt-get install texlive-full

\subsection{\Large Implementacja}

$http://www.deltami.edu.pl/temat/fizyka/mechanika/2015/11/26/Problem_dwoch_cial/$
\bigskip
apt-get install texlive-lang-polish\\
Random citation embeddeed in text.s\\
 sudo apt-get install texlive-bibtex-extra\\
 sudo apt-get install texlive-bibtex-extra biber\\
biber Praca\\
\url{https://www.sharelatex.com/learn/Bibliography_management_with_biblatex}\\
inkscape -D -z --file=drawing.svg --export-pdf=draw.pdf --export-latex

\section{\LARGE Wizualizacja}

\newpage

\section{\LARGE Podsumowanie}

\newpage

\nocite{*}
\printbibliography

\end{document}
