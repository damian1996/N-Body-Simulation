\documentclass[14pt,twoside,a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{blindtext}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{caption}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fontenc}
\usepackage[document]{ragged2e}
\usepackage{bm}
\usepackage{pstricks}
\usepackage{auto-pst-pdf}
\usepackage{hyperref}
\usepackage[
backend=biber,
style=alphabetic,
]{biblatex}
\addbibresource{biblio.bib}
\hypersetup{
  colorlinks, linkcolor=black, citecolor=red
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\newtheorem{theorem}{Prawo}
\newenvironment{myproof}[2] {\paragraph{Dowód:}}{\hfill$\square$}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]

%\geometry{left=2.5cm,right=2.5cm,top=10.0cm,bottom=2.5cm}
\begin{document}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	
	\center
	
	\textsc{\Large Uniwersytet  Jagielloński\\
			 Wydział Matematyki i Informatyki\\
    		 Zespół Katedr i Zakładów Informatyki Matematycznej}\\[1.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\HRule\\[0.4cm]
		
	{\huge\bfseries Wielowątkowa symulacja N ciał z implementacją w architekturze CUDA}\\[0.4cm] % Title 
	
	\HRule\\[1.5cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Autor}\\
			Damian Stachura% \textsc{Stachura}  Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Opiekun}\\
			dr Maciej Ślusarek %\textsc{Ślusarek}  Supervisor's name
		\end{flushright}
	\end{minipage}
	
	\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
\end{titlepage}

\newpage
\tableofcontents

\newpage

\section{\LARGE Przedstawienie problemu symulacji N ciał}
\bigskip
Symulacja N ciał jest zagadnieniem z mechaniki klasycznej, które polega na wyznaczeniu toru ruchów wszystkich ciał danego układu o danych masach, prędkościach i położeniach początkowych w oparciu o prawa ruchu i założenie, że ciała oddziałują ze sobą zgodnie z prawem grawitacji Newtona. \\

\subsection{\Large Szczególne przypadki}
\bigskip
Problem wyznaczenia dokładnego ruchu dowolnej liczby ciał jest trudny, więc można znaleźć wiele prac skupiająych się jedynie na ustalonej, małej liczbe ciał.

\subsubsection{Problem dwóch ciał}
Problem dla dwóch ciał podlegających prawom klasycznej dynamiki Newtona i przyciągających się zgodnie z newtonowskim prawem powszechnego ciążenia został rozstrzygnięty przez J. Bernoulliego przy założeniu, że masa obiektu koncentruje się w jego środku. \cite{fund}

Obydwa ciała poruszają się po krzywych stożkowych, których rodzaj zależy od całkowitej energii układu. Przykładowo, gdy energia jest mała, to ciała nie mogą się od siebie uwolnić, więc krążą wokół siebie po elipsach. (rys. Figure 1)

\subsubsection{Problem trzech ciał}
Problem trzech ciał wciąż nie został rozwiązany w ogólności. Jednakże istnieją rozwiązania dla szczególnych przypadków, jak na przykład \cite{threebody1, threebody2}. Inną wariacją tego problemu jest system, w którym masa jednego z ciał jest zaniedbywalnie mała, jest to tak zwany ograniczony problem trzech ciał - przedstawiony przez J. L. Lagrange'a w XVIII wieku. Badał on układ Słońce-Ziemia-Księżyc. 


\subsection{\Large Zastosowania}
\bigskip
Symulacje N ciał są szeroko wykorzystywanymi narzędziami w fizyce oraz astronomii. Problemem, w którym symulacje są użyteczne jest na przykład dynamika systemu z kilkoma ciałami jak układ Słońce-Ziemia-Księżyc \cite{SEMmisc}, co może pomóc w zrozumieniu działania olbrzymich systemów we wszechświecie. \cite{chaosMisc}
W kosmologii symulacje są wykorzystywane do studiowania procesów tworzenia nieliniowych struktur jak galaktyczne halo z wpływem ciemnej materii \cite{haloDensity}. 
Z kolei, bezpośrednie symulacje N ciał są wykorzystywane na przykład do studiowania dynamicznej ewolucji klastrów gwiazd lub do symulacji dynamiki planetozymali. \cite{dirNBody}. Symulacje są wykorzystywane również w innych dziedzinach, chociażby w algorytmach rysowania grafu skierowanego siłą \cite{visGraph}
\newpage

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{draw.pdf_tex}
    \caption{Symulacja dwóch ciał poruszających się po elipsach}
\end{figure}


\subsection{\Large Implementacja i wykorzystane technologie}
W pierwszej części mojej pracy przedstawię równoległą implementację naiwnego algorytmu symulacji N ciał. W każdym kroku algorytm bezpośrednio wyznacza siły oddziałujące wzajemnie pomiędzy każdymi dwoma ciałami w systemie, przez co oblicza całkowitą siłę oddziałującą na każde ciało w jednym kroku symulacji. W drugiej części zaimplementuję wielowątkowo algorytm Barnes Hut'a, który korzysta z drzew ósemkowych.

Repozytorium jest dostępne pod tym \href{https://github.com/damian1996/N-Body-Simulation}{linkiem}.
Całość została zaimplementowana w C++. Innymi technologiami wykorzystanymi w pracy są OpenGL, CUDA czy Thrust, których zastosowanie zostanie wspomniane później. \\
Pełna instrukcja instalacji niezbędnego oprogramowania do uruchomienia symulacji jest zawarta w repozytorium (dla linuxa Ubuntu).

\section{\LARGE Pierwsze podejście implementacyjne}
\bigskip

\subsection{\Large Sformułowanie problemu}
W celu przedstawienia ogólnego sformułowania problemu potrzebujemy przytoczyć trzy prawa dynamiki sformułowane przez Isaaca Newtona \cite{fund}

\begin{theorem}
Każde ciało pozostaje w stanie spoczynku lub ruchu jednostajnego w linii prostej, chyba że jest zmuszone zmienić ten stan przez zewnętrzne oddziaływanie z innymi ciałami, czyli każde ciało jest w układzie inercjalnym.
\end{theorem}

\begin{theorem}
Szybkość zmiany pędu jest proporcjonalna do siły wywieranej i znajduje się w tym samym kierunku co siła.
\end{theorem}
Co oznacza, że w inercjalnym układzie odniesienia zachodzi równość $F=ma$, gdzie $F$ jest wektorem sum sił działających na obiekt, $m$ to masa obiektu, $a$ to jego przyśpieszenie.

\begin{theorem}
Każdej akcji towarzyszy reakcja równa co do wartości i kierunku, lecz przeciwnie zwrócona.
\end{theorem} 
Co oznacza, że jeśli ciało A działa na ciało B siłą F (akcja), to ciało B działa na ciało A siłą (reakcja) o takiej samej wartości i kierunku, lecz o przeciwnym zwrocie.\\~\\


Niezbędne jest również przytoczenie prawa powszechnego ciążenia Newtona \cite{fund}
\begin{theorem}
Każdy obiekt przyciąga każdy inny obiekt z siłą, która jest wprost proporcjonalna do iloczynu ich mas i odwrotnie proporcjonalna do kwadratu odległości między ich środkami.
\end{theorem}
Czyli między dowolną parą ciał posiadających masy pojawia się siła przyciągająca, która działa na linii łączącej ich środki, a jej wartość rośnie z iloczynem ich mas i maleje z kwadratem odległości.\\~\\

Aplikując to prawo do symulacji N ciał, uzyskujemy że na każde $i$-te ciało działa siła $F_i$ zdefiniowana następująco:\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$gdzie $m_i$ masa ciała na które oddziałują inne ciała, $m_j$ masa ciała oddziałującego na $i$-te ciało, $r_i - r_j$ to różnica wektorów pozycji dwóch ciał, $|r_i - r_j|$ to dystans między ciałami, a $G$ to stała grawitacji i wynosi
\begin{center}
$$G = 6,67408(31)\cdot 10^{-11} \frac{m^{3}}{kg s^2}.$$
\end{center}
Z wykorzystaniem powyższych praw możemy podać następującą definicję
\paragraph{Symulacja N ciał} 
\newcommand{\mi}{\boldsymbol{} \mathrel{\mkern -16mu} \boldsymbol{-}}
$\mi$
Dla N ciał mających ustalone masy oraz początkowe położenie i prędkość, ruch każdego obiektu jest symulowany z wykorzystaniem prawa powszechnego ciążenia oraz poprzez wyznaczenie przyspieszenia obiektu korzystając z drugiego prawa dynamiki Newtona.\\
\bigskip
Potrzebujemy zdefiniować jeszcze jedno pojęcie, jakim jest \textbf{ruch jednostajnie przyśpieszony prostoliniowy}.
Konkretniej będziemy potrzebować wyprowadzonych wzorów na zmianę prędkości i pokonaną drogę przez obiekt w danym odcinku czasu.
$$v_k = v_p + a\cdot t,$$ gdzie $v_k$ jest prędkością po wykonaniu kroku symulacji, $v_p$ jest prędkością początkową, $a$ oznacza wektora przyśpieszenia, a $t$ to czas kroku symulacji.\\
Drugim wzorem jest:
$$s = v_p\cdot t + \frac{a\cdot t^2}{2},$$ gdzie $s$ oznacza drogą przebytą w jednym kroku, a pozostałe oznaczenia są identyczne jak powyżej. Zrodlo??? \\

\subsection{\Large Jednowątkowa wersja naiwnego algorytmu}

Każde ciało na początku symulacji ma pseudolosową pozycję, prędkość oraz masę. W mojej symulacji odległości są wyrażone w metrach, masy ciał są podane w kilogramach, a jednostką prędkości jest metr na sekundę. \\


Prosty pseudokod dla algorytmu symulującego problem N ciał może wyglądać tak:\\
\bigskip

\lstset{
	backgroundcolor=\color{white},
	numbers=left, 
	numbersep=8pt,	
	literate=%
	%	zażółć gęślą jaźń
	{ź}{{\'z}}1
	{ż}{{\.z}}1
	{ń}{{\'n}}1
	{ó}{{\'o}}1
	{ł}{{\l{}}}1
	{ć}{{\'c}}1
	{ą}{{\k{a}}}1
	{ę}{{\k{e}}}1
	{ś}{{\'s}}1
}

\begin{lstlisting}[frame=single, framerule=2pt, caption=Pseudokod naiwnego algorytmu]
ustaw masę oraz początkową pozycję i prędkość dla każdego ciała
while(true):
  for i in {1...N}:
    for j in {1...N}:
      if (i!=j):
        Force[i] += SiłaPomiedzyCiałami(i, j) 
  for i in {1...N}:
    UaktualnijPozycjeCiała(i)
\end{lstlisting}

\bigskip

W liniach 3-6 tego algorytmu liczymy bezpośrednio siłę z jaką dwa ciała oddziałują na siebie dla każdej możliwej pary ciał. Jest to najbardziej kosztowna operacja w tym algorytmie, której złożoność to $\mathcal{O}(N^{2})$. W linii 7 uaktualniamy pozycję każdego ciała uwzględniając całkowitą siłę, która na nie działa. Siła ta wynika z powyżęj przytoczonego wzoru. 
\bigskip
\newtheorem{twr}{Twierdzenie}
\begin{twr}
Jednowątkowy naiwny algorytm dla symulacji N ciał złożoność obliczeniową $\mathcal{O}(N^{2})$.
\end{twr}

\begin{myproof}

\tab Dla każdego z $N$ obiektów musimy policzyć siłę oddziałującą nań z każdym innym obiektem, więc musimy $N\cdot (N-1)$ razy policzyć wartość wzoru wynikającego z prawa $4$. Z tego wynika, że złożoność tej podoperacji $\mathcal{O}(N^{2})$. 
Następnie dla każdego obiektu musimy wyznaczyć jego przyśpieszenie oraz nową pozycję i prędkość, co jesteśmy w stanie zrobić w czasie $\mathcal{O}(N)$.
Poprzez zsumowanie złożoności obu podoperacji, widzimy że złożoność obliczeniowa jednego kroku symulacji naiwnego algorytmu wynosi $\mathcal{O}(N^{2})$.
\end{myproof}

\bigskip

\subsection{\Large Zrównoleglenie naiwnego algorytmu}

Jednakże ten algorytm jest zbyt wolny dla dużej liczby ciał. W tym podrozdziale zoptymalizujemy go poprzez zrównoleglenie obliczeń. Siła oddziałująca na pewne ciało oraz wyznaczenie mu nowej pozycji jest niezależne od takich samych obliczeń dla innych ciał. A to oznacza, że pojedynczy krok algorytmu możemy policzyć równolegle dla każdego obiektu.

\subsubsection{\large Architektura CUDA}
W tym celu wykorzystamy architekturę CUDA. 
Jest to uniwersalna architektura kart graficznych umożliwiająca wykorzystanie ich mocy obliczeniowej w wielu problemach, które mogą się wykonywać zarówno sekwencyjne i wielowątkowo. Wykorzystałem CUDĘ w wersji v9.1.85 z compute compability 3.0 i wyżej. W dzisiejszych czasach poza zastosowaniem w renderowaniu grafiki, jest również często używana do masywnych obliczeń nawet na tysiącach wątków jednocześnie. \\
Wątki są pogrupowane w bloki. W compute compability 3.0 każdy blok może mieć do 1024 wątków. Z kolei bloki są ułożone w gridzie, który może być nawet trójwymiarowy. W wymiarze x może być aż $2^{31}-1$ wątków, w dwóch kolejnych $65535$. \cite{Cuda} Dodatkowo wątki są grupowane w mniejsze grupy niż bloki, zwane warpami, które liczą po 32 wątki. Wątki w jednym warpie są uruchamiane jednocześnie i zarządzane przez warp scheduler. \cite{Cuda} \\
\bigskip
Warto, także wspomnieć o podziale pamięci w programach pisanych w tej architekturze. \\Możemy wyróżnić trzy rodzaje pamięci :
\begin{itemize}
  \item lokalna - osobna dla każdego wątku, czyli wątki mogą mieć zmienne lokalne na swój użytek,
  \item współdzielona - pamięć dzielona przez wszystkie wątki w bloku(ale jest jej tylko 48kb \cite{Cuda}),
  \item globalna - najwolniejsza ze wszystkich rodzajów pamięci, ale wspólna dla wszystkich bloków.
\end{itemize}

\subsubsection{\large Thrust}
Thrust jest szablonową biblioteką dla CUDA bazująca na bibliotece STL z C++. Thrust umożliwia implementację aplikacji wielowątkowych za pośrednictwem interfejsu wysokiego poziomu, który jest w pełni zgodny z CUDA C. Korzystałem z wersji v9.2.88. 


\subsubsection{\large Implementacja wielowątkowa}
W implementacji wykorzystuje dwie szablonowe struktury z biblioteki Thrust.
\textbf{host\_vector} jest odpowiednikiem \textbf{std::vector}. Rezyduje w pamięci hosta powiązanego z równoległym devicem. \textbf{device\_vector} różni się tym, że pamięć związana z nim jest w pamięci device'a. \\ Implementacje podzielimy na dwie funkcje.\\
\bigskip

Funkcja NaiveSimBridge, przedstawiona w listingu 2, przyjmuje jako argument \textbf{host\_vector} z pozycjami wszystkich elementów symulacji, a następnie kopiuje go do \textbf{device\_vector} dla odowiedzialnego za transport pozycji ciał do pamięci device'a. \\Następnie w liniach 3-5 konwertuje \textbf{device\_vector} dla pozycji, prędkości i masy do raw pointerów. Wykorzystywane są w 6 linii, w której wywołujemy kernel NaiveSim. W potrójnych nawiasach specyfikujemy liczbę bloków oraz liczbę wątków w każdym bloku(jest to składnia z CUDA Runtime API). 
W linii 7 kopiuje nowe pozycje z device'a do hosta. 
\bigskip
\bigskip
\bigskip

\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Bridge pomiędzy główną pętlą a kernelem]
void NaiveSimBridge(host_vector &pos, int numberOfBodies, float dt) {
  thrust::device_vector<float> posD = pos;
  float *d_positions = thrust::raw_pointer_cast(posD.data());
  float *d_velocities = thrust::raw_pointer_cast(veloD.data());
  float *d_weights = thrust::raw_pointer_cast(weightsD.data());
  NaiveSim<<<numberOfBlocks, threadsPerBlock>>>(d_positions, 
  	d_velocities, d_weights, numberOfBodies, dt);
  pos = posD;
}
\end{lstlisting}

\bigskip
\bigskip
Kernelem nazywamy funkcję, którą możemy uruchomić dla wielu wątków w pamięci device'a. W tym przypadku kernel NaiveSim, ukazany w listingu 3, jest odpowiedzialny za wyznaczenie nowej pozycji dla każdego ciała. \\
\bigskip

\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Kernel NaiveSim]
const double G = 6.674 * (1e-11);
template <typename T>
__global__ void 
NaiveSim(T *pos, T *velo, T *weigh, int numberOfBodies, double dt) 
{
  int thid = blockIdx.x * blockDim.x + threadIdx.x;
  if(thid>=numberOfBodies) return;
  double pos[3] = {pos[thid*3], pos[thid*3+1], pos[thid*3+2]};
  double weighI = weigh[thid];
  double force[3] = {0.0, 0.0, 0.0};

  for (int j = 0; j < numberOfBodies; j++) {
    if (j != thid) {
      double d[3];
      for(int k=0; k<3; k++) 
      	  d[k] = pos[j*3 + k] - pos[k];
      float dist = (d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);
      dist = dist*sqrt(dist);
      float F = G * (weighI * weigh[j]);
      for(int k=0; k<3; k++) 
		 force[k] += F * d[k] / dist;	
    }
  }
  for(int k=0; k<3; k++) {
    float acc = force[k] / weighI;
    pos[thid*3+k] += velo[thid*3+k]*dt + acc*dt*dt/2;
    velo[thid*3+k] += acc*dt;
  }
}
\end{lstlisting}
\bigskip

W pierwszej linii mamy stałą G, której wartość oznacza wcześniej zdefiniowaną stałą grawitacji.
W sygnaturze kernela widzimy, że przyjmuje trzy raw\_pointery do odpowiednio pozycji, prędkości oraz mas. A poza tym dostaje również delta time, czyli odcinek czasu, w którym wykonywany jest dany krok oraz całkowitą liczbę ciał w symulacji. W 6 linii wyznaczamy indeks obiektu, dla którego będziemy prowadzić obliczenia. Jako że korzystamy tylko z jednowymiarowego schematu bloków, to wystarczy wymnożyć identyfikator bloku z rozmiarem pojedynczego bloku oraz dodać identyfikator wątku w bloku. 
W linii 7 mamy zabezpiecznie na wypadek gdyby obiekt o takim indeksie nie istniał, gdyż czasami liczba wywołanych wątków jest większa niz rzeczywista liczba obiektów. \\
\bigskip
W liniach 8-10 tworzymy zmienne lokalne dla dotychczasowych pozycji oraz masy naszego ciała, żeby zdecydowanie ograniczyć odwołania do droższej pamięci globalnej oraz tworzymy tablicę, w której będziemy liczyć siły działające na ciało.\\
\bigskip
Dalej mamy część, dla której równoleglimy nasz algorytm. Najpierw w liniach 12-23 mamy pętlę, w której liczymy siłę działającą na obiekt o identyfikator, której jest równe wcześniej wyliczonemu thid(threadId) poprzez każdy inny obiekt w symulacji. Postępujemy zgodnie ze wzorem z Prawa 4. W liniach 15-16 wyliczamy wektory odległości między naszym obiektem a każdym innym. W następnych dwóch liniach wyliczamy odległość między tymi dwoma obiektami i podnosimy ją do potęgi trzeciej, tak jak we wzorze. Z kolei w ostatnich liniach tej pętli podstawiamy wszystkie wartości do wzoru, aby obliczyć siłę działającą na ciało. \\
\bigskip
Mając policzoną siłę oddziałującą na obiekt, przechodzimy do wyliczenia nowej pozycji dla obiektu. Jako, że obiekt porusza się ruchem jednostajnym przyśpieszonym, to możemy w tym celu wykorzystać wcześniej wprowadzone wzory.\\ Najpierw w linii 25, korzystając z prawa 2, wyliczamy wektor przyśpieszenia ciała. W linii 26 do aktualnej pozycji dodajemy wektor drogi, o którą przesuwamy ciało po obecnym kroku. I w końcu, linia 27 aktualizuje wektor prędkości.
\bigskip
\bigskip

Wykorzystując architekturę CUDA, mogliśmy przyśpieszyć nasz algorytm. Jednakże, symulacja implementowana tym algorytmem ma jeszcze jeden duży problem. Gdy obiekty są bardzo blisko siebie, to znaczy odległość między nimi jest bliska zera, to wtedy siła, którą na siebie działają jest ogromna. Wtedy ciała wyraźnie się oddalają od siebie, co jest nienaturalne.
W dwóćh następnych podrozdziałach podam dwie optymalizacje, które ograniczają skutki takich sytuacji.

\bigskip
\subsection{\Large Softening} 

Pierwszą optymalizacją jest, tak zwany softening. Polega na modyfikacji wzoru wprowadzonego w Prawie 4, do następującej postaci:
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j\cdot (r_i - r_j)}{(|r_i - r_j|^2 + \epsilon^{2})^{\frac{3}{2}}},$$ 
gdzie wprowadzony $\epsilon$ ma za zadanie nie dopuścić do bardzo małych odległości w mianowniku wzoru. W pracy przyjąłem, że $\epsilon = 0.01$.

\bigskip

\subsection{\Large Aproksymacja kroku}

\bigskip

\section{\LARGE Drugie podejście}
Zrównoleglony naiwny algorytm jest szybszy niż wersja jednowątkowa, jednakże wciąż jest zbyt wolny do symulacji układów z bardzo dużą liczbą ciał. W tym celu zaimplementujemy drugi algorytm, zwany algorytmem Barnesa Hut. \bigskip

\bigskip

\subsection{\Large Drzewa Ósemkowe}

Algorytm jest oparty na drzewach, a dokładniej drzewach ósemkowych.
Struktura drzewa ósemkowego jest następująca(rys. Figure 2):
\begin{itemize}
  \item w naszym przypadku cała przestrzeń trójwymiarowa jest przedstawiana przez sześcian, który jest reprezentowany przez korzeń drzewa
  \item w klasycznej definicji korzeń drzewa ma ośmioro następników, z których każdy reprezentuje jeden z 8 podsześcianów, na które dzielimy duży sześcian reprezentowany przez korzeń.
  \item każdy z kolejnych wierzchołków w drzewie możemy mieć 0 następników, je śli nie zawiera żadnego punktu lub 8 następników, gdy zawiera co najmniej jeden punkt
\end{itemize}

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{tree.pdf_tex}
    \caption{Przykład drzewa ósemkowego z czterema węzłami}
\end{figure}

\subsection{\Large Algorytm Barnes Hut z pseudokodem}
Algorytm Barnes-Hut możemy podzielić na dwie części:
\begin{itemize}
  \item pierwszą z nich jest stworzenie drzewa ósemkowego, które będzie reprezenotwało przestrzeń, w której obecne będą wszystkie obiekty poddawane symulacji
  \item druga część opiera się na przejściu drzewa dla każdego z obiektów i policzenie siły działającej na niego
\end{itemize}
W podstawowej wersji algorytmu obie te części zaimplementujemy rekurencyjnie.

\subsection{\Large Tworzenie drzewa}
Najpierw przedstawmy strukturę węzła w naszym drzewie. Jest to ukazane w listingu poniżej.

\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Struktura węzła w drzewie ósemkowym]
struct NodeBH {
    double mass;
    double totalMass;
    bool hasPoint;
    bool childrenExists;
    std::array<double, 6> boundaries;
    std::array<double, 3> pos;
    std::array<double, 3> centerOfMass;
    std::array<NodeBH*, 8> quads;
};
\end{lstlisting}

Żeby nie tworzyć dwóch osobnych struktur dla węzłów wewnętrznych i zewnętrznych połączyliśmy wszystko w jedną strukturę. \\ Przez to nasza struktura musi zawierać masę ciała oraz jego położenie w przestrzeni(tablica pos). Dodatkowo posiada także pola, które mówią o tym czy jest węzłem wewnętrznym czy zewnętrznym oraz czy posiada punkt(czy jest pusty), a także tablicę z granicami sześcianu, to jest jaki fragment przestrzeni jest ograniczony przez węzeł.\\
\bigskip
Jednakże najważniejszymi polami tej struktury są tablica kwadrantów, czyli ośmiu mniejszych węzłów następników na które dzielimy naszą przestrzeń. \\ A także środek masy oraz całkowita masa punktów w przestrzeni określanej przez ten węzeł. 
\textbf{Środek masy(barycentrum) ciała}  jest punktem w przestrzeni, który zachowuje się tak, jak gdyby w nim skupiona była cała masa układu ciał. Jest zadany następującym wzorem:
$$ x_{srm} = \frac{\sum_{j=1}^N m_j\cdot x_j}{\sum_{j=1}^N m_j},$$ gdzie $m_j$ oznacza masę $j$-tego ciała, $x_j$ oznacza jego $x$-ową współrzędną (dla dwóch pozostałych wzory są analogiczne). \\
\bigskip

W naszej symulacji przyjmujemy jedno założenie: jeśli obiekt wyląduje poza najbardziej zewnętrznym sześcianem wtedy znika z naszej symulacji, nie jest uwzględniany w kolejnym kroku. \\
Początkowe pozycje ciał są losowane z pewnego zakresu $[-init, init]$ w każdym wymiarze. W celu ograniczenia wypadania obiektów z symulacji korzeń drzewa określa w każdym wymiarze przestrzeń, która jest osiem razy większa od początkowej, to znaczy $[-8\cdot init, 8\cdot init]$.
\bigskip

Poniżej przedstawimy pseudokod rekurencyjnego tworzenia drzewa ósemkowego, co będzie wprowadzeniem nas do iteracyjnej implementacji tego problemu w architekturze CUDA w późniejszej części pracy.

\subsubsection{Funkcja CreateTree}
Poniższy listing przedstawia główną funkcję, która odpowiada za stworzenie drzewa ósemkowego dla naszego algorytmu.\\ 
\bigskip
Funkcja ta przyjmuje jako argument tablice z pozycjami wszystkich obiektów. 
Początkowo w linii 2 tworzy następniki dla korzenia drzewa. Następnie w pętli uaktualnia środek masy korzeniowi (linia 6), a potem sprawdza czy punkt nie wyszedł poza całą przestrzeń naszego algorytmu (linia 8). W przypadku, gdy nie wyszedł, wyszukujemy, do którego z następników możemy wstawić nasz punkt (linia 9), a następnie po stworzeniu węzła dla nowego punktu, wstawiamy go do drzewa w linii 11.
\bigskip

\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Pseudokod algorytmu tworzenia drzewa ósemkowego]
void CreateTree(vector<double>& positions) {
    root->addQuads(root->getBoundaries());
    for(unsigned i=0; i<numberOfBodies; i++)
    {	
    	auto pos = copy(positions[i*3], ..., positions[i*3+2]);	        
        root->addPointToCenterOfMass(weights[i], pos);
        if(root->pointIsInSpace(pos)) 
        {
            int index = root->getIndexOfSubCube(pos);
            NodeBH* node = new NodeBH(weights[i], pos);
            InsertNode(node, root->getSubQuad(index));
        }
    }
}
\end{lstlisting}

\bigskip

\subsubsection{Funkcja InsertNode}

W powyższej funkcji wywołujemy funkcję \textbf{InsertNode} dla każdego węzła wstawianego do drzewa. \\
\bigskip
Funkcja ta przyjmuje jako argumenty węzeł $node$, który chcemy wstawić do podprzestrzeni reprezentowanej przez drugi argument, czyli węzeł $quad$.\\ W funkcji tej obsługujemy trzy następujące przypadki:
\begin{itemize}
\item Gdy węzeł jest pusty, wtedy po prostu wstawiamy nowy węzeł w to miejsce. (linie 3-7)
\item Jeśli natknęliśmy się na zewnętrzny wierzchołek drzewa, to musimy zamienić go na węzeł wewnętrzny, stworzyć dla niego osiem następników, a następnie przepchnąć punkt, który do tej pory zawierał do jednego z nich. W dalszej części tego przypadku, musimy wstawić nowy wierzchołek do tej podprzestrzeni, co robimy uaktualniająć środek masy dla korzenia poddrzewa oraz wstawiająć węzeł rekurencyjnie do odpowiedniego poddrzewa. (linie 8-21)
\item Ostatni przypadek obejmuje wewnętrzne węzły, dla których musimy uaktualnić masę o nowy wierzchołek, a potem wstawić go rekurencyjnie do odpowiedniego następnika. (linie 22-33)
\end{itemize}
\bigskip
\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Wstawianie pojedynczego węzła do drzewa]
void InsertNode(NodeBH* node, NodeBH* quad) 
{
    if(!quad->isPoint() and !quad->wasInitializedSubQuads()) 
    {
        // pusty węzeł
        quad.insertHere(node);
    }
    else if(quad->isPoint() and !quad->wasInitializedSubQuads()
    {
        // zewnętrzny węzeł
        quad->setPoint(false);
        quad->pushPointFromHereLower();
        quad->addPointToCenterOfMass(node->getMass(), 
            node->getPositions());
        if(quad->pointIsInQuad(node->getPositions());
        {
            int index = int index = quad->getIndexOfSubCube(
                node->getPositions());
            InsertNode(node, quad->getSubQuad(index));
        }
    }
    else if(!quad->isPoint() && quad->wasInitializedSubQuads())
    {
        // wewnętrzny węzeł
        quad->updateCenterOfMass(node->getMass(), 
            node->getPositions());
        if(quad->pointIsInQuad(node->getPositions());
        {
            int index = int index = quad->getIndexOfSubCube(
                node->getPositions());
            InsertNode(node, quad->getSubQuad(index));
        }
    }
}
\end{lstlisting}

\subsubsection{Złożoność tworzenia drzewa}


\subsection{\Large Spacer po drzewie}

Drzewo zostało stworzone w celu szybszego liczenia siły jaka działa na ciało.\\ Najprostszym podejściem byłoby przejście po drzewie, a kiedy napotkamy punkt w którymś z kwadrantów, to liczymy siłę z jaką oddziałuje na nasz obecny punkt. Jednakże w tym przypadku wciąż musielibyśmy przejść wszystkie węzły w drzewie, więc złożoność nie uległaby poprawie.\\
\bigskip
Z tego powodu wprowadzamy następującą definicję\cite{Aarseth} :
\theoremstyle{definition}
\begin{definition}{Ratio}
Niech s będzie szerokością obszaru obejmowanego przez sześcian oraz niech d będzie odległością między środkiem masy obszaru a punktem, to jeśli $s/d < \Theta$, wtedy liczymy siłę między środkiem masy obszaru a punktem. W przeciwnym przypadku wywołujemy się rekurencyjnie na ośmiu podsześcianach.
\end{definition}

\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              
\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=Liczenie siły oddziałującej na ciało w układzie]
void computeForceForBody(NodeBH* r, std::array<double, 3>& pos, int i)
{
    if(r->isPoint() && !r->wasInitializedSubQuads())
    {
        if(r->getIndex() == i) return;
		// węzeł zewnętrzny		
    	for(int k=0; k<3; k++) 
          forces[i*3+k] += forcesBetweenTwoNodes(r, pos);
    }
    else if(!r->isPoint() && r->wasInitialized())
    {
        if(r->pointIsInQuad(pos)) 
        {
            for(auto* child : r->getQuads()) 
            {
                computeForceForBody(child, pos, i);
            }
            return;
        }

        std::array<double, 6>& boundaries = r->getBoundaries();
        double d = distanceBetweenTwoNodes(pos, 
        	r->getSelectedCenterOfMass());
        double s = boundaries[1] - boundaries[0];
        bool isFarAway = (s/d < theta) ? true : false;
        if(isFarAway)
        {
        	for(int k=0; k<3; k++) 
       		   forces[i*3+k] += forcesBetweenTwoNodes(pos,
       		   		r->getSelectedCenterOfMass());
        }
        else
        {
            for(auto* child : r->getQuads())
            {
                computeForceForBody(child, pos, i);
            }
        }
    }
}
\end{lstlisting}

\bigskip

\textbf{Tutaj dodać opis do algo, można zrobić potem, gdyż mało istotne. Dodatkowo dołożyć cytacje i poprawić bibliografie}

\subsection{\Large Zrównoleglenie algorytmu Barnesa Hut}

\bigskip
 sudo apt-get install texlive-full

\subsection{\Large Implementacja}

$http://www.deltami.edu.pl/temat/fizyka/mechanika/2015/11/26/Problem_dwoch_cial/$
\bigskip
apt-get install texlive-lang-polish\\
Random citation embeddeed in text.s\\
 sudo apt-get install texlive-bibtex-extra\\
 sudo apt-get install texlive-bibtex-extra biber\\
biber Praca\\
\url{https://www.sharelatex.com/learn/Bibliography_management_with_biblatex}\\
inkscape -D -z --file=drawing.svg --export-pdf=draw.pdf --export-latex

\section{\LARGE Wizualizacja}

\subsection{\large OpenGL}
OpenGL jest API do tworzenia grafiki. Skorzystałem z OpenGL3, w celu zwizualizowania symulacji w 3D.



Masa słońca jest definiowana następująco\\
\begin{center}
M\textsubscript{\(\odot\)} = 1.9884\(\cdot 10^{30}\)\\
\end{center}
Symulowane gwiazdy mają wagi z zakresu \([0.5, 10]\) M\textsubscript{\(\odot\)}.\\
- jednostką odległości jest parsek, czyli odległość, dla której paralaksa roczna położenia Ziemi widzianej prostopadle do płaszczyzny orbity wynosi 1 sekundę łuku. W przeliczeniu na metry i po zaokrągleniu jest to 
\begin{center}
\(1\) pc \(\approx\) \(3,2616\) roku świetlnego \(\approx\) \(3,086\cdot 10^{16}\) m\\
\end{center}

W astronomii stała grawitacji jest wyrażana jako 
\begin{center}
$$G = 4,3\cdot 10^{-3} \frac{pc}{M_{\odot}} \frac{km^2}{s^2}$$
\end{center}

\newpage

\section{\LARGE Podsumowanie}

\newpage

\nocite{*}
\printbibliography

\end
{document}
