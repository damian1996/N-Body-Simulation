\documentclass[14pt,twoside,a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{blindtext}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{caption}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fontenc}
\usepackage[document]{ragged2e}
\usepackage{bm}
\usepackage{pstricks}
\usepackage{auto-pst-pdf}
\usepackage{hyperref}
\usepackage[
backend=biber,
style=alphabetic,
]{biblatex}
\addbibresource{biblio.bib}
\hypersetup{
  colorlinks, linkcolor=black
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\newtheorem{theorem}{Prawo}
\newenvironment{myproof}[2] {\paragraph{Dowód:}}{\hfill$\square$}
\newcommand\tab[1][1cm]{\hspace*{#1}}

%\geometry{left=2.5cm,right=2.5cm,top=10.0cm,bottom=2.5cm}
\begin{document}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	
	\center
	
	\textsc{\Large Uniwersytet  Jagielloński\\
			 Wydział Matematyki i Informatyki\\
    		 Zespół Katedr i Zakładów Informatyki Matematycznej}\\[1.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\textsc{\Large}\\[0.5cm]
	
	\HRule\\[0.4cm]
		
	{\huge\bfseries Wielowątkowa symulacja N ciał z implementacją w architekturze CUDA}\\[0.4cm] % Title 
	
	\HRule\\[1.5cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Autor}\\
			Damian \textsc{Stachura} % Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Opiekun}\\
			dr Piotr \textsc{Danilewski} % Supervisor's name
		\end{flushright}
	\end{minipage}
	
	\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
\end{titlepage}

\newpage
\tableofcontents

\newpage

\section{\LARGE Przedstawienie problemu symulacji N ciał}
\bigskip
Symulacja N ciał jest zagadnieniem z mechaniki klasycznej, które polega na wyznaczeniu toru ruchów wszystkich ciał danego układu o danych masach, prędkościach i położeniach początkowych w oparciu o prawa ruchu i założenie, że ciała oddziałują ze sobą zgodnie z prawem grawitacji Newtona. \\

\subsection{\Large Szczególne przypadki}
\bigskip
Problem wyznaczenia ruchu dowolnej liczby ciał jest trudny, więc wielu naukowców próbowało rozstrzygnąć go dla małej, ustalonej liczby ciał.

\subsubsection{Problem dwóch ciał}
Problem dla dwóch ciał podlegających prawom klasycznej dynamiki Newtona i przyciągających się zgodnie z newtonowskim prawem powszechnego ciążenia został rozstrzygnięty przez J. Bernoulliego przy założeniu, że masa obiektu koncentruje się w jego środku. \cite{fund}
Ruch dwóch ciał wygląda wtedy tak, że obiekty poruszają się po krzywych stożkowych, a rodzaj krzywej zależy od całkowitej energii układu. Przykładowo, w przypadku małej energii, gdy ciała nie mogą się od siebie uwolnić, to krążą wokół siebie po elipsach. W innych przypadkach obiekty mogą poruszać się chociażby po hiperboli. 

\subsubsection{Problem trzech ciał}
Problem dla N = 3 wciąż nie jest rozwiązany w ogólności. Istnieją rozwiązania dla szczególnych przypadków\cite{threebody1, threebody2}. Innym ważnym przypadkiem jest problem, w którym masa jednego z ciał jest zaniedbywalnie mała, jest to tak zwany ograniczony problem trzech ciał - przedstawiony przez J. L. Lagrange'a w XVIII wieku. Badał on układ Słońce-Ziemia-Księżyc. 


\subsection{\Large Zastosowania}
\bigskip
Symulacje N ciał są szeroko wykorzystywanymi narzędziami w fizyce oraz astronomii. Problemem, w którym symulacje są użyteczne jest na przykład dynamika systemu z kilkoma ciałami jak układ Słońce-Ziemia-Księżyc\cite{SEMmisc}, której zrozumienie może pomóc zrozumienie działania olbrzymich systemów we wszechświecie.\cite{chaosMisc}
W kosmologii symulacje N ciał są wykorzystywane do studiowania procesów tworzenie nieliniowych struktur jak galaktyczne halo z wpływem ciemnej materii\cite{haloDensity}. 
Bezpośrednie symulacje N ciał są wykorzystywane na przykład do studiowania dynamicznej ewolucji klastrów gwiazd.\cite{dirNBody} 
\newpage

\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{draw.pdf_tex}
    \caption{Symulacja dwóch ciał poruszających się po elipsach}
\end{figure}


\subsection{\Large Implementacja i wykorzystane technologie}
W pierwszej części mojej pracy przedstawię implementację naiwnego algorytmu symulacji N ciał, który w każdym ruchu dla każdego ciała wyznacza jego ruch w oparciu o interakcję z pozostałymi obiektami, więc każda tura działa w czasie $\mathcal{O}(N^{2})$. Kolejnym etapem mojej pracy będzie paralelizacja tego algorytmu.
W drugiej części przybliżę moją implementację algorytmu Barnesa-Huta, który w wersji jednowątkowej ma złożoność obliczeniową $\mathcal{O}(N\log{}N)$, a następnie jego zrównolegloną wersję.

Repozytorium jest dostępne pod tym \href{https://github.com/damian1996/N-Body-Simulation}{linkiem}.
Całość zaimplementowana jest w języku C++ z wykorzystaniem poniżej wymienionych technologii \\
Instalacja do poniższych technologii jest zamieszczona w repozytorium (dla systemów Linux oraz Windows).
\subsubsection{\large Architektura CUDA}
CUDA to uniwersalna architektura procesorów wielordzeniowych (głównie kart graficznych) umożliwiająca zaimplementowanie ich mocy obliczeniowej w wielu problemach, które mogą się wykonywać zarówno sekwencyjne i wielowątkowo. Wykorzystałem CUDĘ w wersji v9.1.85 do paralelizacji dwóch powyżej wspomnianych algorytmów.
\subsubsection{\large Thrust}
Thrust jest szablonową biblioteką dla CUDA bazująca na bibliotece STL z C++. Thrust umożliwia implementację aplikacji wielowątkowych przy minimalnym wysiłku programistycznym za pośrednictwem interfejsu wysokiego poziomu, który jest w pełni zgodny z CUDA C. Wykorzystałem ją do łatwiejszego przenoszenia danych między CPU oraz GPU. Korzystałem z wersji v9.2.88. 
\subsubsection{\large OpenGL}
OpenGL jest API do tworzenia grafiki. Skorzystałem z OpenGL3, w celu zaprezentowania symulacji w 2D.


\section{\LARGE Pierwsze podejście}
\bigskip

\subsection{\Large Sformułowanie problemu}
W celu przedstawienia ogólnego sformułowania problemu potrzebujemy przytoczyć następujące trzy prawa dynamiki sformułowane przez Isaaca Newtona \cite{fund}

\begin{theorem}
Każde ciało pozostaje w stanie spoczynku lub ruchu jednostajnego w linii prostej, chyba że jest zmuszony zmienić ten stan zewnętrzne oddziaływanie z innymi ciałami, czyli każde ciało jest w układzie inercjalnym.
\end{theorem}

\begin{theorem}
Szybkość zmiany pędu jest proporcjonalna do siły wywieranej i znajduje się w tym samym kierunku co siła.
\end{theorem}
Co oznacza, że w inercjalnym układzie odniesienia zachodzi równość $F=ma$, gdzie $F$ jest wektorem sum sił działających na obiekt, $m$ to masa obiektu, $a$ to jego przyśpieszenie.

\begin{theorem}
Każdej akcji towarzyszy reakcja równa co do wartości i kierunku, lecz przeciwnie zwrócona.
\end{theorem} 
Co oznacza, że jeśli ciało A działa na ciało B siłą F (akcja), to ciało B działa na ciało A siłą (reakcja) o takiej samej wartości i kierunku, lecz o przeciwnym zwrocie.\\

Niezbędne jest również przytoczenie prawa powszechnego ciążenia Newtona 
\begin{theorem}
Każdy obiekt przyciąga każdy inny obiekt z siłą, która jest wprost proporcjonalna do iloczynu ich mas i odwrotnie proporcjonalna do kwadratu odległości między ich środkami.
\end{theorem}
Czyli między dowolną parą ciał posiadających masy pojawia się siła przyciągająca, która działa na linii łączącej ich środki, a jej wartość rośnie z iloczynem ich mas i maleje z kwadratem odległości.


Aplikując to prawo do symulacji N ciał, uzyskujemy że na każde $i^{th}$ ciało działa siła $F_i$ zdefiniowana następująco:\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$gdzie $G$ to stała grawitacji, $m_i$ masa ciało na które oddziałują inne ciała, $m_j$ masy ciało oddziałujących na $i^{th}$ ciało, $r_i - r_j$ to różnica wektorów pozycji dwóch ciał, $|r_i - r_j|$ to dystans między ciałami. 

Z wykorzystaniem powyższych praw możemy podać następującą definicję
\paragraph{Symulacja N ciał} -  Dla N ciał mających ustalone masy oraz początkowe położenie oraz prędkość, ruch każdego obiektu jest symulowany z wykorzystaniem prawa powszechnego ciążenia oraz poprzez wyznaczenie przyspieszenia obiektu korzystając z drugiego prawa dynamiki Newtona.

\subsection{\Large Jednowątkowy naiwny algorytm z pseudokodem}

Najprostszy algorytm dla problemu N ciał zadany pseudokodem może wyglądać tak:\\

\lstset{
	backgroundcolor=\color{white},
	numbers=left, 
	numbersep=8pt,	
	literate=%
	%	zażółć gęślą jaźń
	{ź}{{\'z}}1
	{ż}{{\.z}}1
	{ń}{{\'n}}1
	{ó}{{\'o}}1
	{ł}{{\l{}}}1
	{ć}{{\'c}}1
	{ą}{{\k{a}}}1
	{ę}{{\k{e}}}1
	{ś}{{\'s}}1
}

\begin{lstlisting}[frame=single, framerule=2pt, caption=pseudokod]
ustaw mase oraz początkową pozycję i prędkość dla każdego ciała
while(true)
   for i in {1...N}:
       uaktualnijPozycje()
   narysujNowePozycje()
\end{lstlisting}


Każde ciało na początku symulacji ma losowaną pozycję, prędkość oraz wagę. Jednostki przyjęte w symulacji są następujące : \\
- jednostką wagi jest masa słońca. Masa słońca jest definiowana następująco\\
\begin{center}
M\textsubscript{\(\odot\)} = 1.9884\(\cdot 10^{30}\)\\
\end{center}
Symulowane gwiazdy mają wagi z zakresu \([0.5, 10]\) M\textsubscript{\(\odot\)}.\\
- jednostką odległości jest parsek, czyli odległość, dla której paralaksa roczna położenia Ziemi widzianej prostopadle do płaszczyzny orbity wynosi 1 sekundę łuku. W przeliczeniu na metry i po zaokrągleniu jest to 
\begin{center}
\(1\) pc \(\approx\) \(3,2616\) roku świetlnego \(\approx\) \(3,086\cdot 10^{16}\) m\\
\end{center}
Najbardziej złożoną operacją w algorytmie jest uaktualnienie pozycji w każdym obiegu pętli nieskończonej dla każdego ciała w symulacji. W tym celu wykorzystane zostało, wcześniej wprowadzone, Prawo 4. W ten sposób może zostać policzona siła, którą na dane ciało działają wszystkie pozostałe obiekty w symulacji. 

Przypominając, wzór na siłe działającą na ciało wygląda następująco :\\
$$F_i = -G\cdot m_i \sum_{j=1, j\neq i}^N \frac{m_j(r_i - r_j)}{|r_i - r_j|^3},$$ 
gdzie stała grawitacji wynosi
\begin{center}
$$G = 6,67408(31)\cdot 10^{-11} \frac{m^{3}}{kg s^2},$$
\end{center}
W astronomii stała grawitacji jest wyrażana jako 
\begin{center}
$$G = 4,3\cdot 10^{-3} \frac{pc}{M_{\odot}} \frac{km^2}{s^2}$$
\end{center}
Złożoność obliczeniowa naiwnej operacji uaktualnienia pozycji wszyskich obiektów, przedstawia poniższy fakt.

\begin{theorem}
Uaktualnienie pozycji wszystkich ciał ma złożoność obliczeniową $\mathcal{O}(N^{2})$.
\end{theorem}

\begin{myproof}

\tab Dla każdego ciała najpierw musimy wyznaczyć siłę działającą na nie poprzez interakcję z innymi ciałami, czyli dla każdego z $N$ ciał musimy policzyć siłę oddziałującą nań z każdym innym obiektem, więc musimy policzyć wartość wzoru wynikającego z prawa $4$ $N\cdot N-1$ razy, czyli złożoność tej podoperacji $\mathcal{O}(N^{2})$. 
Następnie dla każdego obiektu musimy wyznaczyć jego przyśpieszenie oraz nową pozycję i prędkość, co jesteśmy w stanie zrobić w czasie $\mathcal{O}(N)$.
Poprzez zsumowanie złożoności obu podoperacji, widzimy że złożoność obliczeniowa jednego kroku symulacji naiwnego algorytmu wynosi $\mathcal{O}(N^{2})$.
\end{myproof}


\lstset{backgroundcolor=\color{white}, numbers=left, numbersep=8pt}              

\begin{lstlisting}[language=C++, frame=single, framerule=2pt, caption=uaktualnienie pozycji ciał]
typedef thrust::host_vector<float> tf3;
void StepNaive::compute(tf3& positions, float dt) {
  std::fill(forces.begin(), forces.end(), 0);
  for(unsigned i=0; i<N; i++) {
    for(unsigned j=0; j<N; j++) {
      float distX = positions[j*3] - positions[i*3];
      float distY = positions[j*3+1] - positions[i*3+1];
      if(i!=j && fabs(distX) > 1e-10 && fabs(distY) > 1e-10) {
        float F = G*(weights[i]*weights[j]);
        forces[i*3] += F*distX/(distX*distX+distY*distY);
        forces[i*3+1] += F*distY/(distX*distX+distY*distY);
      }
    }
  }
  for(unsigned i=0; i<N; i++) {
    for(int j=0; j<2; j++) { // x, y
      float acceleration = forces[i*3+j]/weights[i];
      positions[i*3+j] += velocities[i*3+j]*dt + acceleration*dt*dt/2;
      velocities[i*3+j] += acceleration*dt;
    }
  }
}
\end{lstlisting}


\subsection{\Large Paralelizacja naiwnego algorytmu}

\bigskip
\subsection{\Large Implementacja}

\bigskip

\section{\LARGE Drugie podejście}

\bigskip

\subsection{\Large Algorytm Barnesa-Huta z pseudokodem}

\bigskip

\subsection{\Large Zrównoleglenie algorytmu Barnesa-Huta}

\bigskip
 sudo apt-get install texlive-full

\subsection{\Large Implementacja}

$http://www.deltami.edu.pl/temat/fizyka/mechanika/2015/11/26/Problem_dwoch_cial/$
\bigskip
apt-get install texlive-lang-polish\\
Random citation embeddeed in text.s\\
 sudo apt-get install texlive-bibtex-extra\\
 sudo apt-get install texlive-bibtex-extra biber\\
biber Praca\\
\url{https://www.sharelatex.com/learn/Bibliography_management_with_biblatex}\\
inkscape -D -z --file=drawing.svg --export-pdf=draw.pdf --export-latex


\section{\LARGE Podsumowanie}

\newpage

\nocite{*}
\printbibliography

\end{document}
