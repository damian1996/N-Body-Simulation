imho ładnie by było jakbyś zrobił interfejs! czyli: masz interfejs SimulationLogic z dwiema metodami:
calculate(host_vector<float>& positions)
init()
czy coś w ten deseń
i ty implementujesz ten interfejs
wersja na cpu trzyma sobie swoje vectory, liczy sobie po swojemu na cpu
wersja na gpu swoje device_vectory, liczy sobie na cudzie
klasa Simulation ma gdzieś to, jak to się liczy przecież - podaje tylko referencję do vectora pozycji i chce wynik
a jak już chcesz wgl ładnie to możesz otemplatkować sobie to (jakby cię np. bolało to że wersja na cpu ma host_vector a
chcesz zamiast tego zwykły vector, to otemplatkuj sobie ten kontener i pyknie, bo host_vector i vector
mają bardzo podobne metody, dodatkowo możesz otemplatkować sposób symulacji - podając w templatce klase
od liczenia na cpu albo gpu, chociaż do tego starczy nawet argument w konstruktorze…)


to rozwiązuje następujące problemy:
- nie musisz trzymać na hoście velocity i weights, nei musisz ich kopiować, hosta to WGL nie obchodzi
- wysyłanie do rendera teraz polega na tym co ty robisz (pos=posD) tylko nie masz tego dziwactwa że cuda wywołuje render
- jakbyś chciał zrobić kolejną implementację symulacji (np. cuda na kd drzewach) to implementujesz sobie kolejną klasę
 i wszystko bez modyfikowania klasy simulation :3
- rozdzielasz sobie simulation od obliczeń i jest to przez to bardziej czytelne

to znowu powtarzasz kod
główna pętla jest taka sama dla cpu i gpu
ja bym zrobiła tak
- main wybiera rodzaj symulacji
- main tworzy obiekty:
* symulacji
* do obliczeń, w zależności od tego co wybierze user
* renderu
render i obliczenia dale w konstruktorze do symulacji
- symulacja ma główną pętle:
while(nie koniec)
 zrobObliczenia(pozycje&)
 nie koniec = zrenderuj sie(pozycje&)
tyle!

co to jest klasa do obliczen? ... to nie symulacja? ...
z tego co widziałąm ty masz osobną klase do zarządzania tym całym majdanem co się nazywa Simulation i osobną na obliczenia,
więc próbowałam się tego trzymać po prostu chce całkowicie wydzielić te obliczenia fizyczne od renderu, od wszystkiego

i ona sobie grzebie w openglu itd, może trzymać shaderki itp

mamy osobną klase która tylko liczy (tak naprawde to 2 które implementują wspólny interfejs)

i mamy osobną klase, która ma tylko sterowac całym programem i która trzyma te dwie klasy i nimi steruje - niech będzie scena
i ona ma główną pętlę i na smiane wywołuje rysuj i licz

i teraz nie ma wątpliwości - że symulacja nagle zacznie ci rysować na ekran, symulacja nic nie wie o żadnym ekranie
rysowanie nic nie wie o żadnych obliczeniach dopiero ta co kontroluje wie że są takie klasy ale nic ją nie obchodzi
co się dzieje pod spodem - tylko rozkazuje żeby się rysowało / liczyło

rozumiesz dlaczego takie rozdzielenie jest fajne? i jest fajna kompozycja - scena posiada klase od rendera i klase od obliczeń

cudaMalloc(&image_dev, image_width*image_height*4*sizeof(uint8_t));
    cudaMalloc(&result_dev, image_width*image_height*4*sizeof(uint8_t));
    cudaMalloc(&kernel_dev, kernel_width*kernel_height*sizeof(float));
    cudaMemcpy(image_dev, &image[0], image_width*image_height*4*sizeof(uint8_t), cudaMemcpyHostToDevice);
    cudaMemcpy(kernel_dev, kernel_separated, kernel_size*sizeof(float), cudaMemcpyHostToDevice);

    convolve_rows<<<num_of_blocks_row, ROW_SIZE>>>
        (image_dev, result_dev, image_width, image_height, kernel_dev, kernel_size);
    convolve_cols<<<num_of_blocks_col, COLUMN_SIZE>>>
        (result_dev, image_dev, image_width, image_height, kernel_dev, kernel_size);

    cudaMemcpy(&image[0], image_dev, image_width*image_height*4*sizeof(uint8_t), cudaMemcpyDeviceToHost);
    cudaFree(image_dev);
    cudaFree(result_dev);
    cudaFree(kernel_dev);

    //float* d_positions = (float*) malloc(3*N*sizeof(float));
    //float* d_velocities = (float*) malloc(3*N*sizeof(float));
    //float* d_weights = (float*) malloc(N*sizeof(float));

float2


to zrób tak:
weź siły licz właśnie tu
albo najlepiej
zrób funkcję od liczenia sił i nowych pozycji
która ma w argumencie dt
i jeżeli są obiekty blisko siebie
to w pętli, np 10 razy licz siłę+nową pozycje
z dt 10x mniejszym
np.

sudo apt-get update
sudo apt-get install libthrust-dev


CXXOPTIONS = -m64 -std=c++14 -g -Wall -I /usr/local/cuda/include/


test . out : prog
	time =0
	for i in {1..5}; do
	value =" $ $ ( $ ( TIME ) -f % e prog 2 >&1 ) "
	time =" $ $ ( echo " $ $ time + $ $ value " | bc -l ) "
	done
	echo " $ $ time /5" | bc -l > test . out



"    gl_FragColor = vec4(vertex_color, 1.0);\n"

/*
NAIWNY ALGORYTM

z siły wylicza się przyspieszenie a z tego prędkość a z tego droge
i dopiero wtedy przesuwasz

1.
F = G(m1*m2)/r^2

2.
a z tego => a = F/m

3.
przyspieszenie to też wektor
i kulka jakiś tam wektor sobie ma
i przyspieszenie działa na prędkość tak jak prędkość na drogę
czyli modyfikuje prędkość w jakimś czasie

a wzór jest taki:
v += a*dt

4.
2d to też jakaś przestrzeń
i punkt może poruszać się 100 px/s w górę
to nasz wektor prędkości będzie (0, 100)
nom..
i taka najprostsza symulacja polega na tym że bierzemy sobie jakieś dt
(czyli mały odcinek czasu) np. 1/60s xd
nom
i obliczamy o ile punkt się poruszy zakładając że ta prędkość będzie stała
czyli skoro v = s/t, z tego s = v*t czyli:
x += v_x*dt
y += v_y*dt


*/

NEEDED :
GPU NVIDIA

INSTALKI :
CUDA
GLFW / OPENGL3
THRUST





//DO ZACHOWANIA

bool Simulation::update() {
        for(unsigned i=0; i<N; i++) {
            forces[i].fill(0.0f);
        }
        for(unsigned i=0; i<N; i++) {
            for(unsigned j=0; j<N; j++) {
                 // sile parami F(i,j)
                float distX = positions[j][0] - positions[i][0];
                float distY = positions[j][1] - positions[i][1];
                //float distXY2 = distX*distX + distY*distY; // r^2
                //int sgnx = distX > 0 ? 1 : -1;
                //int sgny = distY > 0 ? 1 : -1;
                if(i!=j && fabs(distX) > 1e-10 && fabs(distY) > 1e-10) {
                    float F = G*(weights[i]*weights[j]);
                    //forces[i][0] += sgnx*F/(distX*distX); // force = G(m1*m2)/r^2
                    //forces[i][1] += sgny*F/(distY*distY);

                    //forces[i][0] += F*distX/(distX*distX); // force = G(m1*m2)/r^2
                    //forces[i][1] += F*distY/(distY*distY);

                    forces[i][0] += F*distX/(distX*distX+distY*distY); // force = G(m1*m2)/r^2
                    forces[i][1] += F*distY/(distX*distX+distY*distY);
                }
            }
        }
        for(unsigned i=0; i<N; i++) {
            for(int j=0; j<2; j++) { // x, y
                // biore sile i obliczam przyspieszenie
                float acceleration = forces[i][j]/weights[i];
                // przesun cialo
                positions[i][j] += velocities[i][j]*dt + acceleration*dt*dt/2;
                velocities[i][j] += acceleration*dt;
            }
        }

        painter->sendData(positions, colors, weights);

        return painter->draw();
}
