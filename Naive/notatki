N = 5000
0.0238222 n^2
0.00160737 n^2 GPU
0.118326 nlogn

N = 1000
0.00104774 n^2
0.000407762 n^2 gpu
0.00755371 nlogn

N = 200
0.000185173 n^2
0.000253185 n^2 GPU
0.000438186 nlogn


1) https://en.wikipedia.org/wiki/Z-order_curve#Efficiently_building_quadtrees SORT Z ORDER CURVE



POPRAWKI
1) to w paragrafie o ciałach dodałabym odnosnik że jest obrazek albo ten obrazek wyrównała
2) dolaczanie zrodel do pracy (repo)
3) no po prostu zaznacz że w kroku symulacji masz jednostajnie przyspieszony i przybliżasz symulację za pomoca takich kroków
4) monospace czcionka oraz regularne wciecia listigu
5) mniejsze wciecia kodu

PROFILER
1) upewnij się że kompilujesz z opcją -g
2) valgrind --tool=callgrind
3) kcachegrind <wygenerowany plik>
/usr/local/cuda-9.2/bin/nvprof ./out/main


Masa słońca jest definiowana następująco\\
\begin{center}
M\textsubscript{\(\odot\)} = 1.9884\(\cdot 10^{30}\)\\
\end{center}
Symulowane gwiazdy mają wagi z zakresu \([0.5, 10]\) M\textsubscript{\(\odot\)}.\\
- jednostką odległości jest parsek, czyli odległość, dla której paralaksa roczna położenia Ziemi widzianej prostopadle do płaszczyzny orbity wynosi 1 sekundę łuku. W przeliczeniu na metry i po zaokrągleniu jest to
\begin{center}
\(1\) pc \(\approx\) \(3,2616\) roku świetlnego \(\approx\) \(3,086\cdot 10^{16}\) m\\
\end{center}

W astronomii stała grawitacji jest wyrażana jako
\begin{center}
$$G = 4,3\cdot 10^{-3} \frac{pc}{M_{\odot}} \frac{km^2}{s^2}$$
\end{center}


/*for(int i=0; i<2; i++)
{
    for(int j=0; j<2; j++)
    {
        for(int k=0; k<2; k++)
        {
            double boardsForQuad[6] = {b[0], b[0] + (b[1]-b[0])/2, b[2], b[2] + (b[3]-b[2])/2, b[4], b[4] + (b[5] - b[4])/2};
            //quads.push_back(new NodeBH(boardsForQuad));
        }
    }
}
*/

ENUMS QUICK TUTORIAL
/* Color r = Color::blue;
switch(r)
{
    case Color::red  : std::cout << "red\n";   break;
    case Color::green: std::cout << "green\n"; break;
    case Color::blue : std::cout << "blue\n";  break;
}
// int n = r; // error: no scoped enum to int conversion
int n = static_cast<int>(r); // OK, n = 21 */


                      cudaMalloc(&image_dev, image_width *image_height * 4 *
                                                 sizeof(uint8_t));
cudaMalloc(&result_dev, image_width *image_height * 4 * sizeof(uint8_t));
cudaMalloc(&kernel_dev, kernel_width *kernel_height * sizeof(float));
cudaMemcpy(image_dev, &image[0],
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyHostToDevice);
cudaMemcpy(kernel_dev, kernel_separated, kernel_size * sizeof(float),
           cudaMemcpyHostToDevice);

convolve_rows<<<num_of_blocks_row, ROW_SIZE>>>(image_dev, result_dev,
                                               image_width, image_height,
                                               kernel_dev, kernel_size);
convolve_cols<<<num_of_blocks_col, COLUMN_SIZE>>>(result_dev, image_dev,
                                                  image_width, image_height,
                                                  kernel_dev, kernel_size);

cudaMemcpy(&image[0], image_dev,
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyDeviceToHost);
cudaFree(image_dev);
cudaFree(result_dev);
cudaFree(kernel_dev);

// float* d_positions = (float*) malloc(3*N*sizeof(float));
// float* d_velocities = (float*) malloc(3*N*sizeof(float));
// float* d_weights = (float*) malloc(N*sizeof(float));

float2


to zrób tak:
weź siły licz właśnie tu
albo najlepiej
zrób funkcję od liczenia sił i nowych pozycji
która ma w arandomGeneratorumencie dt
i jeżeli są obiekty blisko siebie
to w pętli, np 10 razy licz siłę+nową pozycje
z dt 10x mniejszym
np.

sudo apt-get update
sudo apt-get install libthrust-dev


CXXOPTIONS = -m64 -std=c++14 -g -Wall -I /usr/local/cuda/include/


test . out : prog
	time =0
	for i in {1..5};
do
  value = " $ $ ( $ ( TIME ) -f % e prog 2 >&1 ) " time =
      " $ $ ( echo " $ $ time + $ $ value " | bc -l ) " done echo
                                          " $ $ time /5" |
      bc - l > test.out

                   "    gl_FragColor = vec4(vertex_color, 1.0);\n"

                   /*
                   NAIWNY ALGORYTM

                   z siły wylicza się przyspieszenie a z tego prędkość a z tego
                   droge
                   i dopiero wtedy przesuwasz

                   1.
                   F = G(m1*m2)/r^2

                   2.
                   a z tego => a = F/m

                   3.
                   przyspieszenie to też wektor
                   i kulka jakiś tam wektor sobie ma
                   i przyspieszenie działa na prędkość tak jak prędkość na drogę
                   czyli modyfikuje prędkość w jakimś czasie

                   a wzór jest taki:
                   v += a*dt

                   4.
                   2d to też jakaś przestrzeń
                   i punkt może poruszać się 100 px/s w górę
                   to nasz wektor prędkości będzie (0, 100)
                   nom..
                   i taka najprostsza symulacja polega na tym że bierzemy sobie
                   jakieś dt
                   (czyli mały odcinek czasu) np. 1/60s xd
                   nom
                   i obliczamy o ile punkt się poruszy zakładając że ta prędkość
                   będzie stała
                   czyli skoro v = s/t, z tego s = v*t czyli:
                   x += v_x*dt
                   y += v_y*dt


                   */

                   NEEDED : GPU NVIDIA

                                INSTALKI : CUDA GLFW /
                   OPENGL3 THRUST

                   // DO ZACHOWANIA
