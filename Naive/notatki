void BarnesHutStep::computeForceForBody(NodeBH* r, std::array<double, 3>& pos, int i)
{
    if(r->isPoint() && !r->wasInitialized())
    {
        // Jesli node jest zewnetrzny, to policz sile ktora wywiera ten node na obecnie rozwazane cialo
        std::array<double, 3> distForDimension;
        double dist = EPS * EPS;
        for(int i=0; i<3; i++) 
        {
            distForDimension[i] = r->getSelectedPosition(i) - pos[i];
            dist = dist + (distForDimension[i] * distForDimension[i]);
        } 
        dist = dist * sqrt(dist);
        // jak sprawdzic czy to te same bodies? Musze zachowac i != j
        float F = G * (r->getMass() * weights[i]);
        for(int i=0; i<3; i++) 
        {
            forces[i * 3 + i] += F * distForDimension[i] / dist;
        }
    }
    else if(!r->isPoint() && r->wasInitialized())
    {
        std::array<double, 6>& boundaries = r->getBoundaries();
        bool isFarAway = false;
        for(int j = 0; j < 3; j++)
        {
            double d = dist(pos[j], r->getSelectedCenterOfMass(j));
            double s = boundaries[2*j + 1] - boundaries[2*j];
            if(BarnesHutStep::minS > s) BarnesHutStep::minS = s;
            if(s/d < theta) 
            {
                isFarAway = true;
            } 
            else 
            {
                isFarAway = false;
                break;
            }
        }
        if(isFarAway)
        {
            std::array<double, 3> distForDimension;
            double dist = EPS * EPS;
            for(int i=0; i<3; i++) 
            {
                distForDimension[i] = r->getSelectedCenterOfMass(i) - pos[i];
                dist = dist + (distForDimension[i] * distForDimension[i]);
            } 
            dist = dist * sqrt(dist);
            float F = G * (r->getTotalMass() * weights[i]);
            for(int i=0; i<3; i++) 
            {
                forces[i * 3 + i] += F * distForDimension[i] / dist;
            }
        }
        else
        {
            for(auto* child : r->getQuads())
            {
                computeForceForBody(child, pos, i);
            }
        }
    }
}

III OPCJA bez vectorow


III OPCJA

0.0029109
0.447578
0.666709
0.569141
0.690313
0.810421
1.04146
1.02326
0.780254
0.673954
0.610857
0.567632
0.523392
0.49063
0.461018
0.431845
0.396703
0.37991
0.36375
0.353005
0.349578
0.346696
0.340666
0.351639
0.343817
0.344596
0.347522
0.345708
0.353614
0.36337

I OPCJA

0.00339677
0.345306
0.319039
0.317166
0.317018
0.318118
0.325653
0.32024
0.321578
0.321631
0.332477
0.327175
0.32723
0.317413
0.319453
0.317104
0.317471
0.320036
0.317074
0.318926
0.335102
0.329858
0.337581
0.336142
0.320759

II OPCJA

0.00321018
0.0814953
0.095533
0.0972236
0.097403
0.0920587
0.100372
0.0940597
0.0993817
0.106551
0.0990933
0.108919
0.10086
0.0999502
0.113015
0.0981307
0.0928862
0.0982084
0.102388
0.094381

/*for(int i=0; i<2; i++)
{
    for(int j=0; j<2; j++)
    {
        for(int k=0; k<2; k++)
        {
            double boardsForQuad[6] = {b[0], b[0] + (b[1]-b[0])/2, b[2], b[2] + (b[3]-b[2])/2, b[4], b[4] + (b[5] - b[4])/2};
            //quads.push_back(new NodeBH(boardsForQuad));
        }
    }
}
*/

PROFILER
1) upewnij się że kompilujesz z opcją -g
2) valgrind --tool=callgrind
3) kcachegrind <wygenerowany plik>

nvprof

ENUMS QUICK TUTORIAL
/* Color r = Color::blue;
switch(r)
{
    case Color::red  : std::cout << "red\n";   break;
    case Color::green: std::cout << "green\n"; break;
    case Color::blue : std::cout << "blue\n";  break;
}
// int n = r; // error: no scoped enum to int conversion
int n = static_cast<int>(r); // OK, n = 21 */


https
    : // arxiv.orandomGenerator/pdf/0806.3950.pdf
https
: // arxiv.orandomGenerator/pdf/1411.6671.pdf
  file
  : /// home/damian/Desktop/praca%20licencjacka/materialy/Gravitational%20N-Body%20Simulatio%20-%20Aarseth,%20Sverre%20J._5510.pdf
    https
    : // arxiv.orandomGenerator/pdf/1105.1082.pdf
      https
      : // pl.wikipedia.orandomGenerator/wiki/Zasada_zachowania_p%C4%99du
        https
        : // pl.wikipedia.orandomGenerator/wiki/Zderzenie_centralne

                CHAOS http
                : // www.maths.ed.ac.uk/~douglas/cortina-v2.pdf
                  sun -
                  earth - moon https
                  : // arxiv.orandomGenerator/pdf/1307.7062.pdf
                    evolution star clusters https
                    : // pdfs.semanticscholar.orandomGenerator/presentation/250f/ee86a085feb0a522e96075cbaebd70837a33.pdf

                      cudaMalloc(&image_dev, image_width *image_height * 4 *
                                                 sizeof(uint8_t));
cudaMalloc(&result_dev, image_width *image_height * 4 * sizeof(uint8_t));
cudaMalloc(&kernel_dev, kernel_width *kernel_height * sizeof(float));
cudaMemcpy(image_dev, &image[0],
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyHostToDevice);
cudaMemcpy(kernel_dev, kernel_separated, kernel_size * sizeof(float),
           cudaMemcpyHostToDevice);

convolve_rows<<<num_of_blocks_row, ROW_SIZE>>>(image_dev, result_dev,
                                               image_width, image_height,
                                               kernel_dev, kernel_size);
convolve_cols<<<num_of_blocks_col, COLUMN_SIZE>>>(result_dev, image_dev,
                                                  image_width, image_height,
                                                  kernel_dev, kernel_size);

cudaMemcpy(&image[0], image_dev,
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyDeviceToHost);
cudaFree(image_dev);
cudaFree(result_dev);
cudaFree(kernel_dev);

// float* d_positions = (float*) malloc(3*N*sizeof(float));
// float* d_velocities = (float*) malloc(3*N*sizeof(float));
// float* d_weights = (float*) malloc(N*sizeof(float));

float2


to zrób tak:
weź siły licz właśnie tu
albo najlepiej
zrób funkcję od liczenia sił i nowych pozycji
która ma w arandomGeneratorumencie dt
i jeżeli są obiekty blisko siebie
to w pętli, np 10 razy licz siłę+nową pozycje
z dt 10x mniejszym
np.

sudo apt-get update
sudo apt-get install libthrust-dev


CXXOPTIONS = -m64 -std=c++14 -g -Wall -I /usr/local/cuda/include/


test . out : prog
	time =0
	for i in {1..5};
do
  value = " $ $ ( $ ( TIME ) -f % e prog 2 >&1 ) " time =
      " $ $ ( echo " $ $ time + $ $ value " | bc -l ) " done echo
                                          " $ $ time /5" |
      bc - l > test.out

                   "    gl_FragColor = vec4(vertex_color, 1.0);\n"

                   /*
                   NAIWNY ALGORYTM

                   z siły wylicza się przyspieszenie a z tego prędkość a z tego
                   droge
                   i dopiero wtedy przesuwasz

                   1.
                   F = G(m1*m2)/r^2

                   2.
                   a z tego => a = F/m

                   3.
                   przyspieszenie to też wektor
                   i kulka jakiś tam wektor sobie ma
                   i przyspieszenie działa na prędkość tak jak prędkość na drogę
                   czyli modyfikuje prędkość w jakimś czasie

                   a wzór jest taki:
                   v += a*dt

                   4.
                   2d to też jakaś przestrzeń
                   i punkt może poruszać się 100 px/s w górę
                   to nasz wektor prędkości będzie (0, 100)
                   nom..
                   i taka najprostsza symulacja polega na tym że bierzemy sobie
                   jakieś dt
                   (czyli mały odcinek czasu) np. 1/60s xd
                   nom
                   i obliczamy o ile punkt się poruszy zakładając że ta prędkość
                   będzie stała
                   czyli skoro v = s/t, z tego s = v*t czyli:
                   x += v_x*dt
                   y += v_y*dt


                   */

                   NEEDED : GPU NVIDIA

                                INSTALKI : CUDA GLFW /
                   OPENGL3 THRUST

                   // DO ZACHOWANIA

                   bool
                   Simulation::update() {
    for (unsigned i = 0; i < N; i++) {
      forces[i].fill(0.0f);
    }
    for (unsigned i = 0; i < N; i++) {
      for (unsigned j = 0; j < N; j++) {
        // sile parami F(i,j)
        float distX = positions[j][0] - positions[i][0];
        float distY = positions[j][1] - positions[i][1];
        // float distXY2 = distX*distX + distY*distY; // r^2
        // int sgnx = distX > 0 ? 1 : -1;
        // int sgny = distY > 0 ? 1 : -1;
        if (i != j && fabs(distX) > 1e-10 && fabs(distY) > 1e-10) {
          float F = G * (weights[i] * weights[j]);
          // forces[i][0] += sgnx*F/(distX*distX); // force = G(m1*m2)/r^2
          // forces[i][1] += sgny*F/(distY*distY);

          // forces[i][0] += F*distX/(distX*distX); // force = G(m1*m2)/r^2
          // forces[i][1] += F*distY/(distY*distY);

          forces[i][0] += F * distX / (distX * distX +
                                       distY * distY); // force = G(m1*m2)/r^2
          forces[i][1] += F * distY / (distX * distX + distY * distY);
        }
      }
    }
    for (unsigned i = 0; i < N; i++) {
      for (int j = 0; j < 2; j++) { // x, y
        // biore sile i obliczam przyspieszenie
        float acceleration = forces[i][j] / weights[i];
        // przesun cialo
        positions[i][j] += velocities[i][j] * dt + acceleration * dt * dt / 2;
        velocities[i][j] += acceleration * dt;
      }
    }

    painter->sendData(positions, colors, weights);

    return painter->draw();
  }
