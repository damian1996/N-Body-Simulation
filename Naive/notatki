# wykres do podsumowania

\begin{figure}[h]
\begin{tikzpicture}
\begin{axis}[
    title={Porównanie czasu działania algorytmów},
    xlabel={Rozmiar kernela},
    ylabel={Czas (ms)},
    xmin=0, xmax=128,
    ymin=0, ymax=1500,
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
 
\addplot[
    color=blue,
    mark=square,
    ]
    coordinates {
    (1,161.25)(3,207.22)(5,238.25)(7,345.54)(9,425.62)(11,469.78)(13,648.63)(15,786.14)(17,909.76)(19,1046.35)(21,1192.08)(23,1402.21)(25,1620.54)(27,1864.30)(29,2090.17)(31,2388.40)
    };
\addplot[
    color=red,
    mark=square,
    ]
    coordinates {
    (1, 168.2)(3, 170.0)(5, 179.5)(7, 247.0)(9, 263.5)(11, 233.9)(13, 218.7)(15, 234.0)(17, 252.5)(19, 298.3)(21, 298.5)(23, 326.6)(25, 356.8)(27, 397.7)(29, 440.5)(31, 473.1)(33, 529.1)(35, 550.0)(37, 624.0)(39, 645.6)(41, 686.7)(43, 748.7)(45, 805.1)(47, 852.9)(49, 917.5)(51, 983.1)(53, 1045.1)(55, 1106.3)(57, 1206.3)(59, 1255.6)(61, 1341.2)(63, 1409.4)
    
    };
\addplot[
    color=green,
    mark=square,
    ]
    coordinates {
    	(1, 208.3)(3, 209.2)(5, 221.7)(7, 200.6)(9, 198.4)(11, 199.1)(13, 239.2)(15, 240.1)(17, 199.0)(19, 255.5)(21, 213.7)(23, 200.3)(25, 235.2)(27, 233.1)(29, 202.1)(31, 203.8)(33, 205.0)(35, 211.1)(37, 235.6)(39, 221.2)(41, 231.9)(43, 258.1)(45, 238.7)(47, 231.8)(49, 240.3)(51, 234.0)(53, 276.5)(55, 276.5)(57, 227.0)(59, 235.0)(61, 265.1)(63, 227.8)(65, 280.7)(67, 249.1)(69, 240.7)(71, 236.3)(73, 256.4)(75, 257.1)(77, 242.7)(79, 292.0)(81, 258.2)(83, 250.4)(85, 248.1)(87, 302.7)(89, 278.7)(91, 294.4)(93, 262.8)(95, 305.1)(97, 295.0)(99, 314.4)(101, 289.2)(103, 309.0)(105, 293.3)(107, 265.5)(109, 322.2)(111, 295.1)(113, 294.8)(115, 269.9)(117, 291.9)(119, 329.9)(121, 311.2)(123, 315.8)(125, 279.2)(127, 335.9)
    };
\legend{Naiwna implementacja, Zoptymalizowana konwolucja, Separable convolution}
\end{axis}
\end{tikzpicture}
\caption{Porównanie czasu działania algorytmów}
\end{figure}

@misc{tutMat,
	author = "???",
	title = "http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/",
}



\bigskip
sudo apt-get install texlive-full

\subsection{\Large Implementacja}

$http://www.deltami.edu.pl/temat/fizyka/mechanika/2015/11/26/Problem_dwoch_cial/$
\bigskip
apt-get install texlive-lang-polish\\
Random citation embeddeed in text.s\\
 sudo apt-get install texlive-bibtex-extra\\
 sudo apt-get install texlive-bibtex-extra biber\\
biber Praca\\
\url{https://www.sharelatex.com/learn/Bibliography_management_with_biblatex}\\
inkscape -D -z --file=drawing.svg --export-pdf=draw.pdf --export-latex
inkscape -D -z --file=zcurve.svg --export-pdf=zcurve.pdf --export-latex

\section{\LARGE Wizualizacja}



1) https://en.wikipedia.org/wiki/Z-order_curve#Efficiently_building_quadtrees SORT Z ORDER CURVE

POPRAWKI
2) dolaczanie zrodel do pracy (repo)

PROFILER
1) upewnij się że kompilujesz z opcją -g
2) valgrind --tool=callgrind
3) kcachegrind <wygenerowany plik>
/usr/local/cuda-9.2/bin/nvprof ./out/main


Masa słońca jest definiowana następująco\\
\begin{center}
M\textsubscript{\(\odot\)} = 1.9884\(\cdot 10^{30}\)\\
\end{center}
Symulowane gwiazdy mają wagi z zakresu \([0.5, 10]\) M\textsubscript{\(\odot\)}.\\
- jednostką odległości jest parsek, czyli odległość, dla której paralaksa roczna położenia Ziemi widzianej prostopadle do płaszczyzny orbity wynosi 1 sekundę łuku. W przeliczeniu na metry i po zaokrągleniu jest to
\begin{center}
\(1\) pc \(\approx\) \(3,2616\) roku świetlnego \(\approx\) \(3,086\cdot 10^{16}\) m\\
\end{center}

W astronomii stała grawitacji jest wyrażana jako
\begin{center}
$$G = 4,3\cdot 10^{-3} \frac{pc}{M_{\odot}} \frac{km^2}{s^2}$$
\end{center}


/*for(int i=0; i<2; i++)
{
    for(int j=0; j<2; j++)
    {
        for(int k=0; k<2; k++)
        {
            double boardsForQuad[6] = {b[0], b[0] + (b[1]-b[0])/2, b[2], b[2] + (b[3]-b[2])/2, b[4], b[4] + (b[5] - b[4])/2};
            //quads.push_back(new NodeBH(boardsForQuad));
        }
    }
}
*/

ENUMS QUICK TUTORIAL
/* Color r = Color::blue;
switch(r)
{
    case Color::red  : std::cout << "red\n";   break;
    case Color::green: std::cout << "green\n"; break;
    case Color::blue : std::cout << "blue\n";  break;
}
// int n = r; // error: no scoped enum to int conversion
int n = static_cast<int>(r); // OK, n = 21 */


                      cudaMalloc(&image_dev, image_width *image_height * 4 *
                                                 sizeof(uint8_t));
cudaMalloc(&result_dev, image_width *image_height * 4 * sizeof(uint8_t));
cudaMalloc(&kernel_dev, kernel_width *kernel_height * sizeof(float));
cudaMemcpy(image_dev, &image[0],
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyHostToDevice);
cudaMemcpy(kernel_dev, kernel_separated, kernel_size * sizeof(float),
           cudaMemcpyHostToDevice);

convolve_rows<<<num_of_blocks_row, ROW_SIZE>>>(image_dev, result_dev,
                                               image_width, image_height,
                                               kernel_dev, kernel_size);
convolve_cols<<<num_of_blocks_col, COLUMN_SIZE>>>(result_dev, image_dev,
                                                  image_width, image_height,
                                                  kernel_dev, kernel_size);

cudaMemcpy(&image[0], image_dev,
           image_width *image_height * 4 * sizeof(uint8_t),
           cudaMemcpyDeviceToHost);
cudaFree(image_dev);
cudaFree(result_dev);
cudaFree(kernel_dev);

// float* d_positions = (float*) malloc(3*N*sizeof(float));
// float* d_velocities = (float*) malloc(3*N*sizeof(float));
// float* d_weights = (float*) malloc(N*sizeof(float));

float2


to zrób tak:
weź siły licz właśnie tu
albo najlepiej
zrób funkcję od liczenia sił i nowych pozycji
która ma w arandomGeneratorumencie dt
i jeżeli są obiekty blisko siebie
to w pętli, np 10 razy licz siłę+nową pozycje
z dt 10x mniejszym
np.

sudo apt-get update
sudo apt-get install libthrust-dev


CXXOPTIONS = -m64 -std=c++14 -g -Wall -I /usr/local/cuda/include/


test . out : prog
	time =0
	for i in {1..5};
do
  value = " $ $ ( $ ( TIME ) -f % e prog 2 >&1 ) " time =
      " $ $ ( echo " $ $ time + $ $ value " | bc -l ) " done echo
                                          " $ $ time /5" |
      bc - l > test.out

                   "    gl_FragColor = vec4(vertex_color, 1.0);\n"

                   /*
                   NAIWNY ALGORYTM

                   z siły wylicza się przyspieszenie a z tego prędkość a z tego
                   droge
                   i dopiero wtedy przesuwasz

                   1.
                   F = G(m1*m2)/r^2

                   2.
                   a z tego => a = F/m

                   3.
                   przyspieszenie to też wektor
                   i kulka jakiś tam wektor sobie ma
                   i przyspieszenie działa na prędkość tak jak prędkość na drogę
                   czyli modyfikuje prędkość w jakimś czasie

                   a wzór jest taki:
                   v += a*dt

                   4.
                   2d to też jakaś przestrzeń
                   i punkt może poruszać się 100 px/s w górę
                   to nasz wektor prędkości będzie (0, 100)
                   nom..
                   i taka najprostsza symulacja polega na tym że bierzemy sobie
                   jakieś dt
                   (czyli mały odcinek czasu) np. 1/60s xd
                   nom
                   i obliczamy o ile punkt się poruszy zakładając że ta prędkość
                   będzie stała
                   czyli skoro v = s/t, z tego s = v*t czyli:
                   x += v_x*dt
                   y += v_y*dt


                   */

                   NEEDED : GPU NVIDIA

                                INSTALKI : CUDA GLFW /
                   OPENGL3 THRUST

                   // DO ZACHOWANIA
